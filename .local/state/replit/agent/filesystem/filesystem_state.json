{"file_contents":{"app.py":{"content":"import os\nfrom flask import Flask, render_template, request, redirect, url_for, session\nfrom config import Config\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom models import db, Product, Transaction, User, UserRole\nfrom models import TransactionStatus\nfrom flask_login import LoginManager, login_required, current_user\nfrom data_initialization import initialize_sample_data\nfrom datetime import datetime\nfrom sqlalchemy import desc, func, inspect\n\n\ndef create_default_admin_user():\n    \"\"\"Create default admin user if none exists - requires ADMIN_PASSWORD env var\"\"\"\n    admin_user = User.query.filter_by(role=UserRole.ADMIN).first()\n    if not admin_user:\n        # Require ADMIN_PASSWORD environment variable for security\n        admin_password = os.environ.get('ADMIN_PASSWORD')\n        if not admin_password:\n            print(\"❌ SECURITY ERROR: ADMIN_PASSWORD environment variable is required to create admin user.\")\n            print(\"   Set ADMIN_PASSWORD environment variable with a secure password (min 8 chars, mixed case, numbers, symbols)\")\n            print(\"   Example: export ADMIN_PASSWORD='MySecureP@ssw0rd123'\")\n            raise RuntimeError(\"Admin user creation requires ADMIN_PASSWORD environment variable for security\")\n        \n        # Validate password strength (same rules as user registration)\n        if len(admin_password) < 8:\n            print(\"❌ SECURITY ERROR: ADMIN_PASSWORD must be at least 8 characters long\")\n            raise RuntimeError(\"Admin password must be at least 8 characters for security\")\n        \n        # Additional password complexity check (same as user registration)\n        has_upper = any(c.isupper() for c in admin_password)\n        has_lower = any(c.islower() for c in admin_password)\n        has_digit = any(c.isdigit() for c in admin_password)\n        \n        if not (has_upper and has_lower and has_digit):\n            print(\"❌ SECURITY ERROR: ADMIN_PASSWORD must contain uppercase letters, lowercase letters, and numbers\")\n            print(\"   Example: MySecureP@ssw0rd123\")\n            raise RuntimeError(\"Admin password must contain uppercase, lowercase, and numbers for security\")\n        \n        admin = User()\n        admin.username = 'admin'\n        admin.email = 'admin@pos.kz'\n        admin.first_name = 'Админ'\n        admin.last_name = 'Жүйесі'\n        admin.role = UserRole.ADMIN\n        admin.set_password(admin_password)\n        db.session.add(admin)\n        db.session.commit()\n        \n        print(f\"✅ SECURE: Admin user created with password from ADMIN_PASSWORD environment variable\")\n\n\ndef create_app():\n    app = Flask(__name__)\n    app.config.from_object(Config)\n    \n    # Add ProxyFix for Replit environment\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n    \n    # Initialize extensions\n    db.init_app(app)\n    \n    # Initialize Flask-Login\n    login_manager = LoginManager()\n    login_manager.init_app(app)\n    login_manager.login_view = 'auth.login'\n    login_manager.login_message = 'Жүйеге кіру қажет / Необходимо войти в систему'\n    \n    @login_manager.user_loader\n    def load_user(user_id):\n        return User.query.get(int(user_id))\n    \n    # Ensure upload directory exists\n    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n    \n    with app.app_context():\n        db.create_all()\n        initialize_sample_data()\n        \n        # Check schema compatibility for promo code features\n        check_promo_schema_compatibility(app)\n        \n        # Initialize bcrypt for the app context\n        from models import bcrypt\n        bcrypt.init_app(app)\n        \n        # Create default admin user if none exists\n        create_default_admin_user()\n    \n    # Register blueprints\n    from views.auth import auth_bp\n    from views.pos import pos_bp\n    from views.inventory import inventory_bp\n    from views.reports import reports_bp\n    app.register_blueprint(auth_bp)\n    app.register_blueprint(pos_bp)\n    app.register_blueprint(inventory_bp)\n    app.register_blueprint(reports_bp)\n    \n    return app\n\n\ndef check_promo_schema_compatibility(app):\n    \"\"\"Check if database schema supports promo code features\"\"\"\n    try:\n        # Use proper schema inspection to check if promo_code_used column exists\n        inspector = inspect(db.engine)\n        transaction_columns = [col['name'] for col in inspector.get_columns('transactions')]\n        \n        if 'promo_code_used' in transaction_columns:\n            app.config['PROMO_FEATURES_ENABLED'] = True\n        else:\n            print(\"WARNING: Promo code features disabled - promo_code_used column not found in transactions table\")\n            app.config['PROMO_FEATURES_ENABLED'] = False\n            \n    except Exception as e:\n        print(f\"WARNING: Promo code features disabled due to schema check error: {e}\")\n        app.config['PROMO_FEATURES_ENABLED'] = False\n        \n    try:\n        # Check if promo_codes table exists\n        inspector = inspect(db.engine)\n        if inspector.has_table('promo_codes'):\n            app.config['PROMO_CODES_TABLE_EXISTS'] = True\n        else:\n            print(\"WARNING: Promo codes table does not exist\")\n            app.config['PROMO_CODES_TABLE_EXISTS'] = False\n    except Exception as e:\n        print(f\"WARNING: Could not check promo_codes table: {e}\")\n        app.config['PROMO_CODES_TABLE_EXISTS'] = False\n\n\n# Create the Flask app\napp = create_app()\n\n# Language support\ndef get_language():\n    \"\"\"Get current language from session\"\"\"\n    return session.get('language', 'kk')  # Default to Kazakh\n\ndef get_text(kk_text, ru_text):\n    \"\"\"Get text based on current language\"\"\"\n    if get_language() == 'ru':\n        return ru_text\n    return kk_text\n\n# Translation dictionaries\nTRANSLATIONS = {\n    'categories': {\n        'Сүт өнімдері': {'kk': 'Сүт өнімдері', 'ru': 'Молочные продукты'},\n        'Нан өнімдері': {'kk': 'Нан өнімдері', 'ru': 'Хлебобулочные'},\n        'Сусындар': {'kk': 'Сусындар', 'ru': 'Напитки'},\n        'Ет өнімдері': {'kk': 'Ет өнімдері', 'ru': 'Мясные продукты'},\n        'Жемістер мен көкөністер': {'kk': 'Жемістер мен көкөністер', 'ru': 'Фрукты и овощи'},\n    },\n    'products': {\n        'Сүт 3.2% 1л': {'kk': 'Сүт 3.2% 1л', 'ru': 'Молоко 3.2% 1л'},\n        'Нан ақ': {'kk': 'Нан ақ', 'ru': 'Хлеб белый'},\n        'Апельсин шырыны 1л': {'kk': 'Апельсин шырыны 1л', 'ru': 'Сок апельсиновый 1л'},\n        'Ірімшік қазақстандық': {'kk': 'Ірімшік қазақстандық', 'ru': 'Сыр казахстанский'},\n        'Алма қызыл': {'kk': 'Алма қызыл', 'ru': 'Яблоки красные'},\n    },\n    'units': {\n        'шт.': {'kk': 'дана', 'ru': 'шт.'},\n        'кг.': {'kk': 'кг.', 'ru': 'кг.'},\n        'л.': {'kk': 'л.', 'ru': 'л.'},\n        'м.': {'kk': 'м.', 'ru': 'м.'},\n        'упак.': {'kk': 'орам', 'ru': 'упак.'},\n    }\n}\n\ndef translate_name(original_name, category='products'):\n    \"\"\"Translate product/category name based on current language\"\"\"\n    translations = TRANSLATIONS.get(category, {})\n    if original_name in translations:\n        return translations[original_name].get(get_language(), original_name)\n    return original_name\n\n# Language switcher route\n@app.route('/set_language/<language>')\ndef set_language(language):\n    \"\"\"Set language preference\"\"\"\n    if language in ['kk', 'ru']:\n        session['language'] = language\n    return redirect(request.referrer or url_for('index'))\n\n# Make language functions available in templates\n@app.context_processor\ndef inject_language_functions():\n    return dict(get_language=get_language, get_text=get_text, translate_name=translate_name, UserRole=UserRole)\n\n# Main dashboard route\n@app.route('/')\n@login_required\ndef index():\n    \"\"\"Main dashboard\"\"\"\n    # Get quick stats for dashboard\n    total_products = Product.query.filter_by(is_active=True).count()\n    low_stock_count = Product.query.filter(Product.stock_quantity <= Product.min_stock_level).count()\n    \n    # Today's sales\n    today = datetime.now().date()\n    today_sales = db.session.query(func.sum(Transaction.total_amount)).filter(\n        func.date(Transaction.created_at) == today,\n        Transaction.status == TransactionStatus.COMPLETED\n    ).scalar() or 0\n    \n    # Recent transactions\n    recent_transactions = Transaction.query.filter_by(status=TransactionStatus.COMPLETED)\\\n        .order_by(desc(Transaction.created_at)).limit(5).all()\n    \n    return render_template('dashboard.html', \n                         total_products=total_products,\n                         low_stock_count=low_stock_count,\n                         today_sales=today_sales,\n                         recent_transactions=recent_transactions)\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found_error(error):\n    return render_template('404.html'), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    db.session.rollback()\n    return render_template('500.html'), 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)","size_bytes":9342},"config.py":{"content":"import os\nfrom datetime import timedelta\n\nclass Config:\n    SECRET_KEY = os.environ.get('SESSION_SECRET')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    SQLALCHEMY_ENGINE_OPTIONS = {\n        \"pool_recycle\": 300,\n        \"pool_pre_ping\": True,\n    }\n    UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static', 'images')\n    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size\n    \n    # Image upload settings\n    ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n    MAX_IMAGE_WIDTH = 800\n    MAX_IMAGE_HEIGHT = 600\n    THUMBNAIL_SIZE = (200, 200)  # For POS display\n    \n    # POS specific settings for Kazakhstan\n    CURRENCY_SYMBOL = '₸'\n    TAX_RATE = 0.12  # 12% VAT (Kazakhstan standard rate)\n    RECEIPT_FOOTER = 'Рахмет сатып алғаныңыз үшін! / Спасибо за покупку!'\n    COUNTRY_CODE = 'KZ'\n    PHONE_FORMAT = '+7 (XXX) XXX-XX-XX'\n    \n    # Session settings\n    PERMANENT_SESSION_LIFETIME = timedelta(hours=8)","size_bytes":1054},"models.py":{"content":"from flask_sqlalchemy import SQLAlchemy\nfrom flask_login import UserMixin\nfrom flask_bcrypt import Bcrypt\nfrom datetime import datetime\nfrom enum import Enum\nfrom sqlalchemy import func\n\ndb = SQLAlchemy()\nbcrypt = Bcrypt()\n\nclass UserRole(Enum):\n    CASHIER = \"cashier\"\n    MANAGER = \"manager\"\n    ADMIN = \"admin\"\n\nclass PaymentMethod(Enum):\n    CASH = \"cash\"\n    CARD = \"card\"\n    TRANSFER = \"transfer\"\n\nclass TransactionStatus(Enum):\n    PENDING = \"pending\"\n    COMPLETED = \"completed\"\n    SUSPENDED = \"suspended\"\n    CANCELLED = \"cancelled\"\n\nclass UnitType(Enum):\n    PIECE = \"шт.\"\n    KILOGRAM = \"кг.\"\n    LITER = \"л.\"\n    METER = \"м.\"\n    PACK = \"упак.\"\n\nclass User(UserMixin, db.Model):\n    __tablename__ = 'users'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    first_name = db.Column(db.String(50), nullable=False)\n    last_name = db.Column(db.String(50), nullable=False)\n    role = db.Column(db.Enum(UserRole), default=UserRole.CASHIER)\n    _is_active = db.Column('is_active', db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_login = db.Column(db.DateTime)\n    \n    # Relationships\n    transactions = db.relationship('Transaction', backref='user', lazy=True, foreign_keys='Transaction.user_id')\n    operation_logs = db.relationship('OperationLog', backref='user', lazy=True, foreign_keys='OperationLog.user_id')\n    \n    def set_password(self, password):\n        \"\"\"Set password hash using bcrypt\"\"\"\n        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')\n    \n    def check_password(self, password):\n        \"\"\"Check password against hash\"\"\"\n        return bcrypt.check_password_hash(self.password_hash, password)\n    \n    @property\n    def full_name(self):\n        \"\"\"Get user's full name\"\"\"\n        return f\"{self.first_name} {self.last_name}\"\n    \n    @property\n    def is_cashier(self):\n        return self.role == UserRole.CASHIER\n    \n    @property\n    def is_manager(self):\n        return self.role == UserRole.MANAGER\n    \n    @property\n    def is_admin(self):\n        return self.role == UserRole.ADMIN\n    \n    @property\n    def is_active(self):\n        \"\"\"Override UserMixin.is_active\"\"\"\n        return self._is_active\n    \n    def can_access(self, required_role):\n        \"\"\"Check if user has required role or higher\"\"\"\n        role_hierarchy = {\n            UserRole.CASHIER: 1,\n            UserRole.MANAGER: 2,\n            UserRole.ADMIN: 3\n        }\n        return role_hierarchy.get(self.role, 0) >= role_hierarchy.get(required_role, 0)\n\nclass Supplier(db.Model):\n    __tablename__ = 'suppliers'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), nullable=False)\n    contact_person = db.Column(db.String(100))\n    phone = db.Column(db.String(20))\n    email = db.Column(db.String(100))\n    address = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    is_active = db.Column(db.Boolean, default=True)\n    \n    # Relationships\n    products = db.relationship('Product', backref='supplier', lazy=True)\n    purchase_orders = db.relationship('PurchaseOrder', backref='supplier', lazy=True)\n\nclass Category(db.Model):\n    __tablename__ = 'categories'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), nullable=False, unique=True)\n    description = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    products = db.relationship('Product', backref='category', lazy=True)\n\nclass Product(db.Model):\n    __tablename__ = 'products'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    sku = db.Column(db.String(50), unique=True, nullable=False)\n    barcode = db.Column(db.String(50), unique=True, nullable=True)  # Barcode/QR code for scanning\n    name = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text)\n    unit_type = db.Column(db.Enum(UnitType), default=UnitType.PIECE)\n    price = db.Column(db.Numeric(10, 2), nullable=False)\n    cost_price = db.Column(db.Numeric(10, 2), default=0.00)  # For profit calculation\n    stock_quantity = db.Column(db.Integer, default=0)\n    min_stock_level = db.Column(db.Integer, default=0)\n    image_filename = db.Column(db.String(100))\n    is_active = db.Column(db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Foreign keys\n    supplier_id = db.Column(db.Integer, db.ForeignKey('suppliers.id'))\n    category_id = db.Column(db.Integer, db.ForeignKey('categories.id'))\n    \n    # Relationships\n    transaction_items = db.relationship('TransactionItem', backref='product', lazy=True)\n    purchase_order_items = db.relationship('PurchaseOrderItem', backref='product', lazy=True)\n    \n    @property\n    def is_low_stock(self):\n        return self.stock_quantity <= self.min_stock_level\n    \n    @property\n    def profit_margin(self):\n        if self.cost_price > 0:\n            return ((self.price - self.cost_price) / self.price * 100)\n        return 0\n\nclass Transaction(db.Model):\n    __tablename__ = 'transactions'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    transaction_number = db.Column(db.String(20), unique=True, nullable=False)\n    status = db.Column(db.Enum(TransactionStatus), default=TransactionStatus.PENDING)\n    subtotal = db.Column(db.Numeric(10, 2), default=0.00)\n    discount_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    tax_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    total_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    cashier_name = db.Column(db.String(100))\n    customer_name = db.Column(db.String(100))\n    promo_code_used = db.Column(db.String(20))  # Store applied promo code\n    notes = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    completed_at = db.Column(db.DateTime)\n    \n    # Foreign key for user tracking\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)\n    \n    # Relationships\n    items = db.relationship('TransactionItem', backref='transaction', lazy=True, cascade='all, delete-orphan')\n    payments = db.relationship('Payment', backref='transaction', lazy=True, cascade='all, delete-orphan')\n\nclass TransactionItem(db.Model):\n    __tablename__ = 'transaction_items'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    quantity = db.Column(db.Numeric(10, 3), nullable=False)\n    unit_price = db.Column(db.Numeric(10, 2), nullable=False)\n    discount_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    total_price = db.Column(db.Numeric(10, 2), nullable=False)\n    \n    # Foreign keys\n    transaction_id = db.Column(db.Integer, db.ForeignKey('transactions.id'), nullable=False)\n    product_id = db.Column(db.Integer, db.ForeignKey('products.id'), nullable=False)\n\nclass Payment(db.Model):\n    __tablename__ = 'payments'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    method = db.Column(db.Enum(PaymentMethod), nullable=False)\n    amount = db.Column(db.Numeric(10, 2), nullable=False)\n    reference_number = db.Column(db.String(100))  # For card/transfer payments\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Foreign key\n    transaction_id = db.Column(db.Integer, db.ForeignKey('transactions.id'), nullable=False)\n\nclass OperationLog(db.Model):\n    __tablename__ = 'operation_logs'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    action = db.Column(db.String(100), nullable=False)  # login, sale, inventory_update, etc.\n    description = db.Column(db.Text)\n    entity_type = db.Column(db.String(50))  # transaction, product, user, etc.\n    entity_id = db.Column(db.Integer)  # ID of the affected entity\n    old_values = db.Column(db.Text)  # JSON string of old values\n    new_values = db.Column(db.Text)  # JSON string of new values\n    ip_address = db.Column(db.String(45))\n    user_agent = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Foreign key\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)\n\nclass PurchaseOrder(db.Model):\n    __tablename__ = 'purchase_orders'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    order_number = db.Column(db.String(20), unique=True, nullable=False)\n    order_date = db.Column(db.DateTime, default=datetime.utcnow)\n    delivery_date = db.Column(db.DateTime)\n    status = db.Column(db.String(20), default='pending')  # pending, received, cancelled\n    total_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    notes = db.Column(db.Text)\n    \n    # Foreign key\n    supplier_id = db.Column(db.Integer, db.ForeignKey('suppliers.id'), nullable=False)\n    \n    # Relationships\n    items = db.relationship('PurchaseOrderItem', backref='purchase_order', lazy=True, cascade='all, delete-orphan')\n\nclass PurchaseOrderItem(db.Model):\n    __tablename__ = 'purchase_order_items'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    quantity = db.Column(db.Integer, nullable=False)\n    unit_cost = db.Column(db.Numeric(10, 2), nullable=False)\n    total_cost = db.Column(db.Numeric(10, 2), nullable=False)\n    \n    # Foreign keys\n    purchase_order_id = db.Column(db.Integer, db.ForeignKey('purchase_orders.id'), nullable=False)\n    product_id = db.Column(db.Integer, db.ForeignKey('products.id'), nullable=False)\n\nclass DiscountRule(db.Model):\n    __tablename__ = 'discount_rules'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text)\n    discount_type = db.Column(db.String(20), nullable=False)  # percentage, fixed_amount\n    discount_value = db.Column(db.Numeric(10, 2), nullable=False)\n    min_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    category_id = db.Column(db.Integer, db.ForeignKey('categories.id'))\n    is_active = db.Column(db.Boolean, default=True)\n    start_date = db.Column(db.DateTime)\n    end_date = db.Column(db.DateTime)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\nclass PromoCode(db.Model):\n    __tablename__ = 'promo_codes'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    code = db.Column(db.String(20), nullable=False)  # Unique constraint handled separately\n    name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text)\n    discount_type = db.Column(db.String(20), nullable=False)  # percentage, fixed_amount\n    discount_value = db.Column(db.Numeric(10, 2), nullable=False)\n    min_amount = db.Column(db.Numeric(10, 2), default=0.00)\n    max_uses = db.Column(db.Integer, default=None)  # None = unlimited\n    current_uses = db.Column(db.Integer, default=0)\n    is_active = db.Column(db.Boolean, default=True)\n    start_date = db.Column(db.DateTime)\n    end_date = db.Column(db.DateTime)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Add constraints and indexes for production\n    __table_args__ = (\n        db.Index('ix_promo_codes_upper_code', func.upper(code), unique=True),\n        db.Index('ix_promo_codes_active', 'is_active'),\n        db.CheckConstraint('discount_value >= 0', name='check_discount_value_positive'),\n        db.CheckConstraint('current_uses >= 0', name='check_current_uses_positive'),\n        db.CheckConstraint('max_uses IS NULL OR max_uses >= 0', name='check_max_uses_positive'),\n    )","size_bytes":11657},"pyproject.toml":{"content":"[project]\nname = \"pos-system\"\nversion = \"0.1.0\"\ndescription = \"Point of Sale System for Kazakhstan market\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"flask-login>=0.6.3\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask-wtf>=1.2.2\",\n    \"gunicorn>=23.0.0\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.2\",\n    \"pillow>=11.3.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"reportlab>=4.4.4\",\n    \"sqlalchemy>=2.0.43\",\n    \"werkzeug>=3.1.3\",\n    \"wtforms>=3.2.1\",\n    \"flask-bcrypt>=1.0.1\",\n]\n\n[tool.setuptools]\npackages = []\n\n[tool.setuptools.package-data]\n\"*\" = [\"templates/**/*\", \"static/**/*\"]\n","size_bytes":632},"replit.md":{"content":"# POS System for Kazakhstan Market\n\n## Overview\nThis is a Point of Sale (POS) system designed specifically for the Kazakhstan market, featuring bilingual support (Kazakh/Russian). The system provides comprehensive retail management functionality including sales processing, inventory management, and reporting.\n\n## Recent Changes (September 27, 2025)\n- **Mobile Optimization Complete**: Implemented comprehensive mobile and tablet optimizations for Kazakhstan market\n- **Tablet-Optimized POS Interface**: Added responsive design with Bootstrap breakpoints and touch-friendly controls\n- **Barcode Scanner Integration**: Added QuaggaJS-based barcode scanning with camera access and product search API\n- **Popular Products System**: Implemented backend analytics for tracking popular products based on sales data\n- **Quick Access Panel**: Created smart product recommendations panel with 7-day and 30-day popularity metrics\n- **Enhanced Database**: Added barcode field to products table with sample Kazakhstan market data\n- **API Endpoints**: Created `/api/search-barcode` and `/api/quick-access-products` for mobile functionality\n- **Touch-Optimized UI**: Improved button sizes, spacing, and interactions for tablet cashier efficiency\n- **Bilingual Mobile Support**: All mobile features support Kazakh/Russian interface switching\n\n## Previous Changes (September 26, 2025)\n- Set up the application for Replit environment\n- Migrated from SQLite to PostgreSQL database  \n- Configured proper Flask application with ProxyFix middleware for Replit\n- Installed all Python dependencies using uv package manager\n- Created proper workflow configuration for port 5000 with webview output\n- Fixed analytics function to handle None query results properly\n- Created main.py entry point for Gunicorn deployment\n- Configured deployment settings for autoscale production deployment\n- Set up static/images directory for file uploads\n- Verified all major features work: Dashboard, POS Terminal, Inventory Management\n\n## Architecture\n- **Backend**: Flask application with SQLAlchemy ORM\n- **Database**: PostgreSQL (Replit-managed)\n- **Frontend**: HTML templates with Bootstrap styling\n- **Language Support**: Kazakh and Russian (bilingual interface)\n\n## Key Features\n- **POS Terminal**: Complete sales transaction processing\n- **Inventory Management**: Product catalog with stock tracking\n- **Reporting**: Sales analytics and reporting dashboard\n- **Kazakhstan-specific**: Tax calculations (12% VAT), currency (₸), local language support\n\n## Project Structure\n- `app.py` - Main Flask application with all routes and business logic\n- `models.py` - Database models for all entities\n- `config.py` - Application configuration\n- `templates/` - Jinja2 HTML templates\n- `static/` - Static assets (CSS, JS, images)\n\n## Database Configuration\n- Uses PostgreSQL via DATABASE_URL environment variable\n- Automatic database initialization with sample Kazakhstan market data\n- Models include: Products, Categories, Suppliers, Transactions, Payments, etc.\n\n## Deployment\n- Configured for Replit autoscale deployment\n- Uses Gunicorn WSGI server for production\n- Listens on port 5000 for both development and production\n\n## Dependencies\nAll dependencies are managed through pyproject.toml and include Flask, SQLAlchemy, PostgreSQL driver, and other essential packages.","size_bytes":3331},"main.py":{"content":"from app import app\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)","size_bytes":98},"data_initialization.py":{"content":"\"\"\"\nData initialization module for POS system\nHandles creation of sample data for Kazakhstan market\n\"\"\"\nfrom typing import List\nfrom datetime import datetime, timedelta\nfrom models import (\n    db, Category, Supplier, Product, PromoCode, \n    UnitType\n)\n\n\ndef create_sample_categories() -> List[Category]:\n    \"\"\"Create sample categories for Kazakhstan market\"\"\"\n    categories_data = [\n        {\"name\": \"Сүт өнімдері\", \"description\": \"Сүт, ірімшік, йогурт\"},\n        {\"name\": \"Нан өнімдері\", \"description\": \"Нан, тоқаш, печенье\"},\n        {\"name\": \"Сусындар\", \"description\": \"Шырын, газдалған сусындар, су\"},\n        {\"name\": \"Ет өнімдері\", \"description\": \"Ет, шұжық, деликатестер\"},\n        {\"name\": \"Жемістер мен көкөністер\", \"description\": \"Жаңа жемістер мен көкөністер\"}\n    ]\n    \n    categories = []\n    for data in categories_data:\n        category = Category()\n        category.name = data[\"name\"]\n        category.description = data[\"description\"]\n        categories.append(category)\n        db.session.add(category)\n    \n    return categories\n\n\ndef create_sample_supplier() -> Supplier:\n    \"\"\"Create sample supplier for Kazakhstan market\"\"\"\n    supplier = Supplier()\n    supplier.name = \"ЖШС АлматыТрейд\"\n    supplier.contact_person = \"Асылбек Нұрболов\"\n    supplier.phone = \"+7 (727) 250-30-40\"\n    supplier.email = \"orders@almatytrade.kz\"\n    supplier.address = \"Алматы қ., Абай д-лы, 120, 050000\"\n    \n    db.session.add(supplier)\n    return supplier\n\n\ndef create_sample_products(supplier: Supplier, categories: List[Category]) -> List[Product]:\n    \"\"\"Create sample products for Kazakhstan market\"\"\"\n    products_data = [\n        {\n            \"sku\": \"MLK001\", \"name\": \"Сүт 3.2% 1л\", \"price\": 320.00, \"cost_price\": 220.00,\n            \"stock_quantity\": 50, \"min_stock_level\": 10, \"unit_type\": UnitType.PIECE,\n            \"category_idx\": 0\n        },\n        {\n            \"sku\": \"BRD001\", \"name\": \"Нан ақ\", \"price\": 180.00, \"cost_price\": 120.00,\n            \"stock_quantity\": 30, \"min_stock_level\": 5, \"unit_type\": UnitType.PIECE,\n            \"category_idx\": 1\n        },\n        {\n            \"sku\": \"JCE001\", \"name\": \"Апельсин шырыны 1л\", \"price\": 580.00, \"cost_price\": 410.00,\n            \"stock_quantity\": 25, \"min_stock_level\": 8, \"unit_type\": UnitType.PIECE,\n            \"category_idx\": 2\n        },\n        {\n            \"sku\": \"CHE001\", \"name\": \"Ірімшік қазақстандық\", \"price\": 2200.00, \"cost_price\": 1560.00,\n            \"stock_quantity\": 15, \"min_stock_level\": 3, \"unit_type\": UnitType.KILOGRAM,\n            \"category_idx\": 0\n        },\n        {\n            \"sku\": \"APL001\", \"name\": \"Алма қызыл\", \"price\": 890.00, \"cost_price\": 590.00,\n            \"stock_quantity\": 40, \"min_stock_level\": 10, \"unit_type\": UnitType.KILOGRAM,\n            \"category_idx\": 4\n        }\n    ]\n    \n    products = []\n    for data in products_data:\n        product = Product()\n        product.sku = data[\"sku\"]\n        product.name = data[\"name\"]\n        product.price = data[\"price\"]\n        product.cost_price = data[\"cost_price\"]\n        product.stock_quantity = data[\"stock_quantity\"]\n        product.min_stock_level = data[\"min_stock_level\"]\n        product.unit_type = data[\"unit_type\"]\n        product.supplier_id = supplier.id\n        product.category_id = categories[data[\"category_idx\"]].id\n        \n        products.append(product)\n        db.session.add(product)\n    \n    return products\n\n\ndef create_sample_promo_codes() -> List[PromoCode]:\n    \"\"\"Create sample promo codes for testing\"\"\"\n    promo_data = [\n        {\n            \"code\": \"SAVE10\", \"name\": \"10% скидка\", \n            \"description\": \"Скидка 10% на любую покупку\",\n            \"discount_type\": \"percentage\", \"discount_value\": 10.00, \n            \"min_amount\": 500.00, \"max_uses\": 100, \"current_uses\": 0, \n            \"is_active\": True\n        },\n        {\n            \"code\": \"NEWCUSTOMER\", \"name\": \"Скидка новому клиенту\", \n            \"description\": \"200₸ скидка для новых клиентов\",\n            \"discount_type\": \"fixed_amount\", \"discount_value\": 200.00, \n            \"min_amount\": 1000.00, \"max_uses\": 50, \"current_uses\": 0, \n            \"is_active\": True\n        },\n        {\n            \"code\": \"WEEKEND\", \"name\": \"Выходная скидка\", \n            \"description\": \"15% скидка на выходные\",\n            \"discount_type\": \"percentage\", \"discount_value\": 15.00, \n            \"min_amount\": 300.00, \"max_uses\": None, \"current_uses\": 0, \n            \"is_active\": True, \"start_date\": datetime.utcnow(),\n            \"end_date\": datetime.utcnow() + timedelta(days=30)\n        }\n    ]\n    \n    promos = []\n    for data in promo_data:\n        promo = PromoCode()\n        for key, value in data.items():\n            setattr(promo, key, value)\n        \n        promos.append(promo)\n        db.session.add(promo)\n    \n    return promos\n\n\ndef initialize_sample_data() -> None:\n    \"\"\"Initialize database with sample data if empty\"\"\"\n    if Category.query.count() == 0:\n        # Create categories for Kazakhstan market\n        categories = create_sample_categories()\n        \n        # Create Kazakhstan supplier\n        supplier = create_sample_supplier()\n        \n        db.session.commit()\n        \n        # Create sample products for Kazakhstan market\n        products = create_sample_products(supplier, categories)\n        \n        db.session.commit()\n        \n        # Create sample promo codes for testing\n        if PromoCode.query.count() == 0:\n            promos = create_sample_promo_codes()\n            db.session.commit()","size_bytes":5857},"services/__init__.py":{"content":"# Services module for business logic","size_bytes":36},"utils/__init__.py":{"content":"# Utilities module for helper functions","size_bytes":39},"utils/helpers.py":{"content":"\"\"\"\nHelper utilities for POS system\n\"\"\"\nimport os\nimport secrets\nimport string\nimport uuid\nimport imghdr\nfrom datetime import datetime\nfrom functools import wraps\nfrom flask import session, request, flash, redirect, url_for, current_app\nfrom flask_login import current_user\nfrom werkzeug.utils import secure_filename\nfrom PIL import Image, ImageOps\nfrom models import db, OperationLog, UserRole\n\n\ndef generate_transaction_number():\n    \"\"\"Generate unique transaction number\"\"\"\n    timestamp = datetime.now().strftime('%Y%m%d')\n    random_part = ''.join(secrets.choice(string.digits) for _ in range(4))\n    return f\"TXN{timestamp}{random_part}\"\n\n\ndef generate_order_number():\n    \"\"\"Generate unique purchase order number\"\"\"\n    timestamp = datetime.now().strftime('%Y%m%d')\n    random_part = ''.join(secrets.choice(string.digits) for _ in range(4))\n    return f\"PO{timestamp}{random_part}\"\n\n\ndef log_operation(action, description=None, entity_type=None, entity_id=None, old_values=None, new_values=None):\n    \"\"\"Log user operations\"\"\"\n    if current_user.is_authenticated:\n        log = OperationLog()\n        log.user_id = current_user.id\n        log.action = action\n        log.description = description\n        log.entity_type = entity_type\n        log.entity_id = entity_id\n        log.old_values = old_values\n        log.new_values = new_values\n        log.ip_address = request.remote_addr\n        log.user_agent = request.user_agent.string\n        \n        db.session.add(log)\n        db.session.commit()\n\n\ndef require_role(required_role):\n    \"\"\"Decorator to require specific user role\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                flash('Жүйеге кіру қажет / Необходимо войти в систему', 'error')\n                return redirect(url_for('login'))\n            \n            if not current_user.can_access(required_role):\n                flash('Бұл әрекетке рұқсат жоқ / Недостаточно прав доступа', 'error')\n                return redirect(url_for('index'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator","size_bytes":2259},"utils/image_processing.py":{"content":"\"\"\"\nImage processing utilities for POS system\n\"\"\"\nimport os\nimport uuid\nimport imghdr\nfrom flask import current_app\nfrom werkzeug.utils import secure_filename\nfrom PIL import Image, ImageOps\n\n\ndef allowed_file(filename):\n    \"\"\"Check if uploaded file has allowed extension\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']\n\n\ndef validate_image(file):\n    \"\"\"Validate uploaded image file\"\"\"\n    if not file or file.filename == '':\n        return False, 'Файл не выбран'\n    \n    if not allowed_file(file.filename):\n        return False, 'Недопустимый тип файла. Разрешены: PNG, JPG, JPEG, GIF'\n    \n    # Check file content type\n    file.seek(0)\n    header = file.read(512)\n    file.seek(0)\n    \n    format = imghdr.what(None, header)\n    if not format or format not in ['jpeg', 'png', 'gif']:\n        return False, 'Файл не является изображением'\n    \n    return True, 'OK'\n\n\ndef generate_unique_filename(original_filename):\n    \"\"\"Generate unique filename for uploaded image (normalized to .jpg)\"\"\"\n    unique_id = str(uuid.uuid4())[:8]\n    secure_name = secure_filename(original_filename.rsplit('.', 1)[0])\n    return f\"{unique_id}_{secure_name}.jpg\"\n\n\ndef process_product_image(file, filename):\n    \"\"\"Process uploaded product image - resize and create thumbnail (all saved as JPEG)\"\"\"\n    try:\n        # Open and process the image\n        image = Image.open(file)\n        \n        # Convert RGBA to RGB if necessary\n        if image.mode == 'RGBA':\n            background = Image.new('RGB', image.size, (255, 255, 255))\n            background.paste(image, mask=image.split()[-1] if image.mode == 'RGBA' else None)\n            image = background\n        elif image.mode != 'RGB':\n            image = image.convert('RGB')\n        \n        # Auto-orient the image\n        image = ImageOps.exif_transpose(image)\n        \n        # Resize main image if it's too large\n        max_size = (current_app.config['MAX_IMAGE_WIDTH'], current_app.config['MAX_IMAGE_HEIGHT'])\n        image.thumbnail(max_size, Image.Resampling.LANCZOS)\n        \n        # Save main image as JPEG (filename already has .jpg extension)\n        main_image_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'products', filename)\n        os.makedirs(os.path.dirname(main_image_path), exist_ok=True)\n        image.save(main_image_path, 'JPEG', quality=85, optimize=True)\n        \n        # Create and save thumbnail as JPEG\n        thumbnail = image.copy()\n        thumbnail.thumbnail(current_app.config['THUMBNAIL_SIZE'], Image.Resampling.LANCZOS)\n        \n        thumbnail_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'products', 'thumbnails', filename)\n        os.makedirs(os.path.dirname(thumbnail_path), exist_ok=True)\n        thumbnail.save(thumbnail_path, 'JPEG', quality=80, optimize=True)\n        \n        return True, filename\n        \n    except Exception as e:\n        return False, f'Ошибка обработки изображения: {str(e)}'\n\n\ndef delete_product_image(filename):\n    \"\"\"Delete product image and thumbnail\"\"\"\n    if not filename:\n        return\n    \n    main_image_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'products', filename)\n    thumbnail_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'products', 'thumbnails', filename)\n    \n    # Delete main image\n    if os.path.exists(main_image_path):\n        try:\n            os.remove(main_image_path)\n        except OSError:\n            pass\n    \n    # Delete thumbnail\n    if os.path.exists(thumbnail_path):\n        try:\n            os.remove(thumbnail_path)\n        except OSError:\n            pass","size_bytes":3738},"utils/language.py":{"content":"\"\"\"\nLanguage and translation utilities for POS system\n\"\"\"\nfrom flask import session\n\n\n# Translation dictionaries for Kazakhstan market\nTRANSLATIONS = {\n    'categories': {\n        'Сүт өнімдері': {'kk': 'Сүт өнімдері', 'ru': 'Молочные продукты'},\n        'Нан өнімдері': {'kk': 'Нан өнімдері', 'ru': 'Хлебобулочные'},\n        'Сусындар': {'kk': 'Сусындар', 'ru': 'Напитки'},\n        'Ет өнімдері': {'kk': 'Ет өнімдері', 'ru': 'Мясные продукты'},\n        'Жемістер мен көкөністер': {'kk': 'Жемістер мен көкөністер', 'ru': 'Фрукты и овощи'},\n    },\n    'products': {\n        'Сүт 3.2% 1л': {'kk': 'Сүт 3.2% 1л', 'ru': 'Молоко 3.2% 1л'},\n        'Нан ақ': {'kk': 'Нан ақ', 'ru': 'Хлеб белый'},\n        'Апельсин шырыны 1л': {'kk': 'Апельсин шырыны 1л', 'ru': 'Сок апельсиновый 1л'},\n        'Ірімшік қазақстандық': {'kk': 'Ірімшік қазақстандық', 'ru': 'Сыр казахстанский'},\n        'Алма қызыл': {'kk': 'Алма қызыл', 'ru': 'Яблоки красные'},\n    },\n    'units': {\n        'шт.': {'kk': 'дана', 'ru': 'шт.'},\n        'кг.': {'kk': 'кг.', 'ru': 'кг.'},\n        'л.': {'kk': 'л.', 'ru': 'л.'},\n        'м.': {'kk': 'м.', 'ru': 'м.'},\n        'упак.': {'kk': 'орам', 'ru': 'упак.'},\n    }\n}\n\n\ndef get_language():\n    \"\"\"Get current language from session\"\"\"\n    return session.get('language', 'kk')  # Default to Kazakh\n\n\ndef get_text(kk_text, ru_text):\n    \"\"\"Get text based on current language\"\"\"\n    if get_language() == 'ru':\n        return ru_text\n    return kk_text\n\n\ndef translate_name(original_name, category='products'):\n    \"\"\"Translate product/category name based on current language\"\"\"\n    translations = TRANSLATIONS.get(category, {})\n    if original_name in translations:\n        return translations[original_name].get(get_language(), original_name)\n    return original_name","size_bytes":2161},"views/__init__.py":{"content":"# Views module for POS system","size_bytes":29},"views/auth.py":{"content":"\"\"\"\nAuthentication views for POS system\n\"\"\"\nimport os\nfrom datetime import datetime\nfrom flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom models import db, User, UserRole\nfrom utils.helpers import log_operation, require_role\n\nauth_bp = Blueprint('auth', __name__, url_prefix='/auth')\n\n\ndef create_default_admin_user():\n    \"\"\"Create default admin user if none exists - requires ADMIN_PASSWORD env var\"\"\"\n    admin_user = User.query.filter_by(role=UserRole.ADMIN).first()\n    if not admin_user:\n        # Require ADMIN_PASSWORD environment variable for security\n        admin_password = os.environ.get('ADMIN_PASSWORD')\n        if not admin_password:\n            print(\"❌ SECURITY ERROR: ADMIN_PASSWORD environment variable is required to create admin user.\")\n            print(\"   Set ADMIN_PASSWORD environment variable with a secure password (min 8 chars, mixed case, numbers, symbols)\")\n            print(\"   Example: export ADMIN_PASSWORD='MySecureP@ssw0rd123'\")\n            raise RuntimeError(\"Admin user creation requires ADMIN_PASSWORD environment variable for security\")\n        \n        # Validate password strength (same rules as user registration)\n        if len(admin_password) < 8:\n            print(\"❌ SECURITY ERROR: ADMIN_PASSWORD must be at least 8 characters long\")\n            raise RuntimeError(\"Admin password must be at least 8 characters for security\")\n        \n        # Additional password complexity check (same as user registration)\n        has_upper = any(c.isupper() for c in admin_password)\n        has_lower = any(c.islower() for c in admin_password)\n        has_digit = any(c.isdigit() for c in admin_password)\n        \n        if not (has_upper and has_lower and has_digit):\n            print(\"❌ SECURITY ERROR: ADMIN_PASSWORD must contain uppercase letters, lowercase letters, and numbers\")\n            print(\"   Example: MySecureP@ssw0rd123\")\n            raise RuntimeError(\"Admin password must contain uppercase, lowercase, and numbers for security\")\n        \n        admin = User()\n        admin.username = 'admin'\n        admin.email = 'admin@pos.kz'\n        admin.first_name = 'Админ'\n        admin.last_name = 'Жүйесі'\n        admin.role = UserRole.ADMIN\n        admin.set_password(admin_password)\n        db.session.add(admin)\n        db.session.commit()\n        \n        print(f\"✅ SECURE: Admin user created with password from ADMIN_PASSWORD environment variable\")\n\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"User login\"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('main.index'))\n    \n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        \n        user = User.query.filter_by(username=username).first()\n        \n        if user and user.check_password(password) and user.is_active:\n            login_user(user)\n            user.last_login = datetime.utcnow()\n            db.session.commit()\n            \n            log_operation('login', f'User logged in: {user.username}')\n            \n            next_page = request.args.get('next')\n            flash(f'Сәлем, {user.first_name}! / Добро пожаловать, {user.first_name}!', 'success')\n            return redirect(next_page) if next_page else redirect(url_for('main.index'))\n        else:\n            flash('Қате логин немесе құпия сөз / Неверный логин или пароль', 'error')\n    \n    return render_template('auth/login.html')\n\n\n@auth_bp.route('/logout')\n@login_required\ndef logout():\n    \"\"\"User logout\"\"\"\n    log_operation('logout', f'User logged out: {current_user.username}')\n    logout_user()\n    flash('Сіз жүйеден шықтыңыз / Вы вышли из системы', 'info')\n    return redirect(url_for('auth.login'))\n\n\n@auth_bp.route('/register', methods=['GET', 'POST'])\n@login_required\n@require_role(UserRole.ADMIN)\ndef register():\n    \"\"\"Register new user (admin only)\"\"\"\n    if request.method == 'POST':\n        username = request.form.get('username')\n        email = request.form.get('email')\n        password = request.form.get('password')\n        first_name = request.form.get('first_name')\n        last_name = request.form.get('last_name')\n        role = request.form.get('role')\n        \n        # Validate password strength\n        if not password or len(password) < 8:\n            flash('Құпия сөз кемінде 8 таңбадан тұруы керек / Пароль должен содержать минимум 8 символов', 'error')\n            return render_template('auth/register.html')\n        \n        # Additional password complexity check\n        has_upper = any(c.isupper() for c in password)\n        has_lower = any(c.islower() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        \n        if not (has_upper and has_lower and has_digit):\n            flash('Құпия сөзде үлкен әріп, кіші әріп және сан болуы керек / Пароль должен содержать заглавные буквы, строчные буквы и цифры', 'error')\n            return render_template('auth/register.html')\n        \n        # Check if user already exists\n        if User.query.filter_by(username=username).first():\n            flash('Мұндай пайдаланушы бар / Пользователь уже существует', 'error')\n            return render_template('auth/register.html')\n        \n        if User.query.filter_by(email=email).first():\n            flash('Мұндай email бар / Email уже зарегистрирован', 'error')\n            return render_template('auth/register.html')\n        \n        # Create new user\n        new_user = User()\n        new_user.username = username\n        new_user.email = email\n        new_user.first_name = first_name\n        new_user.last_name = last_name\n        new_user.role = UserRole(role)\n        new_user.set_password(password)\n        \n        db.session.add(new_user)\n        db.session.commit()\n        \n        log_operation('user_create', f'New user created: {username}', 'user', new_user.id)\n        flash(f'Пайдаланушы құрылды / Пользователь {username} создан', 'success')\n        return redirect(url_for('auth.users'))\n    \n    return render_template('auth/register.html')\n\n\n@auth_bp.route('/users')\n@login_required\n@require_role(UserRole.MANAGER)\ndef users():\n    \"\"\"List all users (manager and admin only)\"\"\"\n    users = User.query.all()\n    return render_template('auth/users.html', users=users)","size_bytes":6775},"views/pos.py":{"content":"from flask import Blueprint, render_template, request, jsonify, session, current_app\nfrom flask_login import login_required, current_user\nfrom models import db, Product, Category, Transaction, TransactionItem, Payment, PromoCode, OperationLog\nfrom models import PaymentMethod, TransactionStatus, UnitType, UserRole\nfrom sqlalchemy import or_, desc, func\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nimport json\nimport secrets\nimport string\n\n# Create Blueprint\npos_bp = Blueprint('pos', __name__)\n\n# Helper functions\ndef generate_transaction_number():\n    \"\"\"Generate unique transaction number\"\"\"\n    timestamp = datetime.now().strftime('%Y%m%d')\n    random_part = ''.join(secrets.choice(string.digits) for _ in range(4))\n    return f\"TXN{timestamp}{random_part}\"\n\ndef log_operation(action, description=None, entity_type=None, entity_id=None, old_values=None, new_values=None):\n    \"\"\"Log user operations for audit trail\"\"\"\n    if current_user.is_authenticated:\n        try:\n            log_entry = OperationLog()\n            log_entry.action = action\n            log_entry.description = description\n            log_entry.entity_type = entity_type\n            log_entry.entity_id = entity_id\n            log_entry.old_values = json.dumps(old_values) if old_values else None\n            log_entry.new_values = json.dumps(new_values) if new_values else None\n            log_entry.ip_address = request.remote_addr\n            log_entry.user_agent = request.headers.get('User-Agent')\n            log_entry.user_id = current_user.id\n            db.session.add(log_entry)\n            db.session.commit()\n        except Exception as e:\n            print(f\"Failed to log operation: {e}\")\n\ndef get_language():\n    \"\"\"Get current language from session\"\"\"\n    return session.get('language', 'kk')  # Default to Kazakh\n\ndef translate_name(original_name, category='products'):\n    \"\"\"Translate product/category name based on current language\"\"\"\n    # Translation dictionaries\n    TRANSLATIONS = {\n        'categories': {\n            'Сүт өнімдері': {'kk': 'Сүт өнімдері', 'ru': 'Молочные продукты'},\n            'Нан өнімдері': {'kk': 'Нан өнімдері', 'ru': 'Хлебобулочные'},\n            'Сусындар': {'kk': 'Сусындар', 'ru': 'Напитки'},\n            'Ет өнімдері': {'kk': 'Ет өнімдері', 'ru': 'Мясные продукты'},\n            'Жемістер мен көкөністер': {'kk': 'Жемістер мен көкөністер', 'ru': 'Фрукты и овощи'},\n        },\n        'products': {\n            'Сүт 3.2% 1л': {'kk': 'Сүт 3.2% 1л', 'ru': 'Молоко 3.2% 1л'},\n            'Нан ақ': {'kk': 'Нан ақ', 'ru': 'Хлеб белый'},\n            'Апельсин шырыны 1л': {'kk': 'Апельсин шырыны 1л', 'ru': 'Сок апельсиновый 1л'},\n            'Ірімшік қазақстандық': {'kk': 'Ірімшік қазақстандық', 'ru': 'Сыр казахстанский'},\n            'Алма қызыл': {'kk': 'Алма қызыл', 'ru': 'Яблоки красные'},\n        },\n        'units': {\n            'шт.': {'kk': 'дана', 'ru': 'шт.'},\n            'кг.': {'kk': 'кг.', 'ru': 'кг.'},\n            'л.': {'kk': 'л.', 'ru': 'л.'},\n            'м.': {'kk': 'м.', 'ru': 'м.'},\n            'упак.': {'kk': 'орам', 'ru': 'упак.'},\n        }\n    }\n    \n    translations = TRANSLATIONS.get(category, {})\n    if original_name in translations:\n        return translations[original_name].get(get_language(), original_name)\n    return original_name\n\ndef update_transaction_totals(transaction):\n    \"\"\"Update transaction totals based on items\"\"\"\n    # Ensure all values are Decimal for proper arithmetic\n    subtotal = Decimal('0.00')\n    for item in transaction.items:\n        item_total = item.total_price or Decimal('0.00')\n        item_discount = item.discount_amount or Decimal('0.00')\n        subtotal += (item_total - item_discount)\n    \n    transaction.subtotal = subtotal\n    transaction.tax_amount = subtotal * Decimal('0.12')  # 12% VAT (Kazakhstan rate)\n    transaction.total_amount = subtotal + transaction.tax_amount - (transaction.discount_amount or Decimal('0.00'))\n\n# Routes\n\n@pos_bp.route('/pos')\n@login_required\ndef pos():\n    \"\"\"POS Terminal Interface\"\"\"\n    categories = Category.query.all()\n    # Translate category names for current language\n    for category in categories:\n        category.translated_name = translate_name(category.name, 'categories')\n    return render_template('pos.html', categories=categories)\n\n@pos_bp.route('/api/products/search')\n@login_required\ndef search_products():\n    \"\"\"API endpoint for live product search\"\"\"\n    query = request.args.get('q', '').strip()\n    category_id = request.args.get('category_id')\n    \n    if len(query) < 2 and not category_id:\n        return jsonify([])\n    \n    # Build search query\n    search_query = Product.query.filter_by(is_active=True)\n    \n    if query:\n        search_query = search_query.filter(\n            or_(\n                Product.name.ilike(f'%{query}%'),\n                Product.sku.ilike(f'%{query}%')\n            )\n        )\n    \n    if category_id:\n        search_query = search_query.filter_by(category_id=category_id)\n    \n    products = search_query.limit(10).all()\n    \n    return jsonify([{\n        'id': p.id,\n        'sku': p.sku,\n        'name': translate_name(p.name, 'products'),\n        'price': float(p.price),\n        'stock_quantity': p.stock_quantity,\n        'unit_type': translate_name(p.unit_type.value, 'units'),\n        'image_filename': p.image_filename\n    } for p in products])\n\n@pos_bp.route('/api/search-barcode')\n@login_required\ndef search_barcode():\n    \"\"\"API endpoint for barcode product search\"\"\"\n    barcode = request.args.get('code', '').strip()\n    \n    if not barcode:\n        return jsonify({\n            'success': False,\n            'error': 'Barcode is required'\n        })\n    \n    # Search by barcode first, then by SKU as fallback\n    product = Product.query.filter_by(barcode=barcode, is_active=True).first()\n    \n    if not product:\n        # Fallback: try to find by SKU (in case barcode is same as SKU)\n        product = Product.query.filter_by(sku=barcode, is_active=True).first()\n    \n    if product:\n        return jsonify({\n            'success': True,\n            'product': {\n                'id': product.id,\n                'sku': product.sku,\n                'barcode': product.barcode,\n                'name': translate_name(product.name, 'products'),\n                'price': float(product.price),\n                'stock_quantity': product.stock_quantity,\n                'unit_type': translate_name(product.unit_type.value, 'units'),\n                'image_filename': product.image_filename,\n                'category_name': translate_name(product.category.name, 'categories') if product.category else None,\n                'supplier_name': product.supplier.name if product.supplier else None\n            }\n        })\n    else:\n        return jsonify({\n            'success': False,\n            'error': f'Product with barcode {barcode} not found'\n        })\n\n@pos_bp.route('/api/popular-products')\n@login_required\ndef get_popular_products():\n    \"\"\"API endpoint for getting popular/frequently bought products\"\"\"\n    try:\n        limit = min(int(request.args.get('limit', 10)), 20)  # Max 20 products\n        days = min(int(request.args.get('days', 30)), 90)  # Max 90 days\n        \n        # Calculate product popularity based on transaction frequency and quantity\n        # within the specified time period\n        from datetime import datetime, timedelta\n        \n        cutoff_date = datetime.utcnow() - timedelta(days=days)\n        \n        # Get popular products with sales statistics\n        popular_products_query = db.session.query(\n            Product.id,\n            Product.name,\n            Product.sku,\n            Product.price,\n            Product.stock_quantity,\n            Product.unit_type,\n            Product.image_filename,\n            func.count(TransactionItem.id).label('transaction_count'),\n            func.sum(TransactionItem.quantity).label('total_sold'),\n            func.avg(TransactionItem.quantity).label('avg_quantity_per_sale')\n        ).join(\n            TransactionItem, Product.id == TransactionItem.product_id\n        ).join(\n            Transaction, TransactionItem.transaction_id == Transaction.id\n        ).filter(\n            Product.is_active == True,\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at >= cutoff_date\n        ).group_by(\n            Product.id, Product.name, Product.sku, Product.price, \n            Product.stock_quantity, Product.unit_type, Product.image_filename\n        ).order_by(\n            func.count(TransactionItem.id).desc(),  # Primary: transaction frequency\n            func.sum(TransactionItem.quantity).desc()  # Secondary: total quantity sold\n        ).limit(limit)\n        \n        popular_products = popular_products_query.all()\n        \n        # Format response\n        products_data = []\n        for product in popular_products:\n            products_data.append({\n                'id': product.id,\n                'name': translate_name(product.name, 'products'),\n                'sku': product.sku,\n                'price': float(product.price),\n                'stock_quantity': product.stock_quantity,\n                'unit_type': translate_name(product.unit_type.value, 'units'),\n                'image_filename': product.image_filename,\n                'popularity_stats': {\n                    'transaction_count': product.transaction_count,\n                    'total_sold': float(product.total_sold) if product.total_sold else 0,\n                    'avg_quantity_per_sale': round(float(product.avg_quantity_per_sale), 2) if product.avg_quantity_per_sale else 0\n                }\n            })\n        \n        return jsonify({\n            'success': True,\n            'products': products_data,\n            'period_days': days,\n            'total_count': len(products_data)\n        })\n        \n    except Exception as e:\n        print(f\"Error getting popular products: {e}\")\n        return jsonify({\n            'success': False,\n            'error': 'Failed to retrieve popular products'\n        })\n\n@pos_bp.route('/api/quick-access-products')\n@login_required \ndef get_quick_access_products():\n    \"\"\"API endpoint for getting products for quick access based on multiple factors\"\"\"\n    try:\n        # Get products based on:\n        # 1. Recent popularity (last 7 days)\n        # 2. Overall popularity (last 30 days) \n        # 3. Current stock availability\n        \n        from datetime import datetime, timedelta\n        \n        recent_cutoff = datetime.utcnow() - timedelta(days=7)\n        overall_cutoff = datetime.utcnow() - timedelta(days=30)\n        \n        # Recent popular products (last 7 days)\n        recent_popular = db.session.query(\n            Product.id,\n            func.count(TransactionItem.id).label('recent_sales')\n        ).join(\n            TransactionItem, Product.id == TransactionItem.product_id\n        ).join(\n            Transaction, TransactionItem.transaction_id == Transaction.id\n        ).filter(\n            Product.is_active == True,\n            Product.stock_quantity > 0,  # Only in-stock items\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at >= recent_cutoff\n        ).group_by(Product.id).subquery()\n        \n        # Get products with both recent and overall popularity\n        quick_access_products = db.session.query(\n            Product.id,\n            Product.name,\n            Product.sku,\n            Product.price,\n            Product.stock_quantity,\n            Product.unit_type,\n            Product.image_filename,\n            recent_popular.c.recent_sales,\n            func.count(TransactionItem.id).label('overall_sales')\n        ).outerjoin(\n            recent_popular, Product.id == recent_popular.c.id\n        ).join(\n            TransactionItem, Product.id == TransactionItem.product_id\n        ).join(\n            Transaction, TransactionItem.transaction_id == Transaction.id\n        ).filter(\n            Product.is_active == True,\n            Product.stock_quantity > 0,  # Only available items\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at >= overall_cutoff\n        ).group_by(\n            Product.id, Product.name, Product.sku, Product.price,\n            Product.stock_quantity, Product.unit_type, Product.image_filename,\n            recent_popular.c.recent_sales\n        ).order_by(\n            # Prioritize items with recent sales, then overall sales\n            func.coalesce(recent_popular.c.recent_sales, 0).desc(),\n            func.count(TransactionItem.id).desc()\n        ).limit(8).all()  # Limit to 8 for quick access panel\n        \n        # Format response\n        products_data = []\n        for product in quick_access_products:\n            products_data.append({\n                'id': product.id,\n                'name': translate_name(product.name, 'products'),\n                'sku': product.sku,\n                'price': float(product.price),\n                'stock_quantity': product.stock_quantity,\n                'unit_type': translate_name(product.unit_type.value, 'units'),\n                'image_filename': product.image_filename,\n                'recent_sales': product.recent_sales or 0,\n                'overall_sales': product.overall_sales\n            })\n        \n        return jsonify({\n            'success': True,\n            'products': products_data,\n            'total_count': len(products_data)\n        })\n        \n    except Exception as e:\n        print(f\"Error getting quick access products: {e}\")\n        return jsonify({\n            'success': False,\n            'error': 'Failed to retrieve quick access products'\n        })\n\n# Transaction API Routes\n\n@pos_bp.route('/api/transaction/start', methods=['POST'])\n@login_required\ndef start_transaction():\n    \"\"\"Start a new transaction\"\"\"\n    try:\n        data = request.get_json() or {}\n        cashier_name = data.get('cashier_name', 'Кассир')\n        customer_name = data.get('customer_name', '')\n        \n        transaction = Transaction(  # type: ignore\n            transaction_number=generate_transaction_number(),\n            status=TransactionStatus.PENDING,\n            cashier_name=cashier_name,\n            customer_name=customer_name,\n            user_id=current_user.id\n        )\n        \n        db.session.add(transaction)\n        db.session.commit()\n        \n        # Store transaction ID in session\n        session['current_transaction_id'] = transaction.id\n        \n        return jsonify({\n            'success': True,\n            'transaction_id': transaction.id,\n            'transaction_number': transaction.transaction_number\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/add_item', methods=['POST'])\ndef add_item_to_transaction():\n    \"\"\"Add item to current transaction\"\"\"\n    try:\n        data = request.get_json() or {}\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n        \n        transaction = Transaction.query.get(transaction_id)\n        if not transaction or transaction.status != TransactionStatus.PENDING:\n            return jsonify({'success': False, 'error': 'Транзакция недоступна'}), 400\n        \n        product = Product.query.get(data['product_id'])\n        if not product:\n            return jsonify({'success': False, 'error': 'Товар не найден'}), 404\n        \n        quantity = Decimal(str(data['quantity']))\n        if quantity <= 0:\n            return jsonify({'success': False, 'error': 'Неверное количество'}), 400\n        \n        # Check stock\n        if product.stock_quantity < float(quantity):\n            return jsonify({'success': False, 'error': 'Недостаточно товара на складе'}), 400\n        \n        # Create new item\n        item = TransactionItem(  # type: ignore\n            transaction_id=transaction_id,\n            product_id=product.id,\n            quantity=quantity,\n            unit_price=product.price,\n            total_price=quantity * product.price,\n            discount_amount=Decimal('0.00')\n        )\n        db.session.add(item)\n        \n        # Update transaction totals\n        update_transaction_totals(transaction)\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'item': {\n                'product_name': product.name,\n                'quantity': quantity,\n                'unit_price': float(product.price),\n                'total_price': float(quantity * product.price)\n            },\n            'transaction_total': float(transaction.total_amount)\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/current')\n@login_required\ndef get_current_transaction():\n    \"\"\"Get current transaction details\"\"\"\n    transaction_id = session.get('current_transaction_id')\n    \n    if not transaction_id:\n        return jsonify({'success': False, 'error': 'Нет активной транзакции'})\n    \n    transaction = Transaction.query.get(transaction_id)\n    if not transaction:\n        return jsonify({'success': False, 'error': 'Транзакция не найдена'})\n    \n    items = []\n    for item in transaction.items:\n        items.append({\n            'id': item.id,\n            'product_name': item.product.name,\n            'sku': item.product.sku,\n            'quantity': float(item.quantity),\n            'unit_price': float(item.unit_price),\n            'discount_amount': float(item.discount_amount),\n            'total_price': float(item.total_price)\n        })\n    \n    return jsonify({\n        'success': True,\n        'transaction': {\n            'id': transaction.id,\n            'number': transaction.transaction_number,\n            'subtotal': float(transaction.subtotal),\n            'discount_amount': float(transaction.discount_amount),\n            'tax_amount': float(transaction.tax_amount),\n            'total_amount': float(transaction.total_amount),\n            'items': items\n        }\n    })\n\n@pos_bp.route('/api/transaction/complete', methods=['POST'])\ndef complete_transaction():\n    \"\"\"Complete transaction with payments\"\"\"\n    try:\n        data = request.get_json() or {}\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n        \n        transaction = Transaction.query.get(transaction_id)\n        if not transaction or transaction.status != TransactionStatus.PENDING:\n            return jsonify({'success': False, 'error': 'Транзакция недоступна'}), 400\n        \n        payments = data.get('payments', [])\n        if not payments:\n            return jsonify({'success': False, 'error': 'Не указаны способы оплаты'}), 400\n        \n        # Validate payment amounts\n        total_payment = sum(Decimal(str(p['amount'])) for p in payments)\n        if abs(total_payment - transaction.total_amount) > Decimal('0.01'):\n            return jsonify({'success': False, 'error': 'Сумма оплаты не совпадает с общей суммой'}), 400\n        \n        # Create payment records\n        for payment_data in payments:\n            payment = Payment(  # type: ignore\n                transaction_id=transaction.id,\n                method=PaymentMethod(payment_data['method']),\n                amount=Decimal(str(payment_data['amount'])),\n                reference_number=payment_data.get('reference_number')\n            )\n            db.session.add(payment)\n        \n        # Update stock quantities\n        for item in transaction.items:\n            item.product.stock_quantity -= int(item.quantity)\n        \n        # Handle promo code usage increment atomically if promo code was used\n        if transaction.promo_code_used:\n            promo = db.session.query(PromoCode).filter(\n                func.upper(PromoCode.code) == transaction.promo_code_used.upper(),\n                PromoCode.is_active == True\n            ).with_for_update().first()\n            \n            if promo:\n                # Final validation before incrementing usage\n                if promo.max_uses and promo.current_uses >= promo.max_uses:\n                    # This should not happen if validation was done correctly earlier\n                    db.session.rollback()\n                    return jsonify({'success': False, 'error': 'Промокод исчерпан на момент завершения транзакции'}), 400\n                \n                promo.current_uses += 1\n        \n        # Complete transaction\n        transaction.status = TransactionStatus.COMPLETED\n        transaction.completed_at = datetime.utcnow()\n        transaction.user_id = current_user.id if current_user.is_authenticated else None\n        \n        db.session.commit()\n        \n        # Log the completed sale\n        log_operation(\n            'sale_completed',\n            f'Transaction {transaction.transaction_number} completed for ₸{transaction.total_amount}',\n            'transaction',\n            transaction.id,\n            None,\n            {\n                'transaction_number': transaction.transaction_number,\n                'total_amount': float(transaction.total_amount),\n                'items_count': len(transaction.items),\n                'payment_methods': [p['method'] for p in payments]\n            }\n        )\n        \n        # Log inventory updates\n        for item in transaction.items:\n            log_operation(\n                'inventory_update',\n                f'Stock reduced for {item.product.name}: -{int(item.quantity)} units',\n                'product',\n                item.product.id,\n                {'stock_quantity': item.product.stock_quantity + int(item.quantity)},\n                {'stock_quantity': item.product.stock_quantity}\n            )\n        \n        # Clear current transaction from session\n        session.pop('current_transaction_id', None)\n        \n        return jsonify({\n            'success': True,\n            'transaction_number': transaction.transaction_number,\n            'total_amount': float(transaction.total_amount)\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/suspend', methods=['POST'])\ndef suspend_transaction():\n    \"\"\"Suspend current transaction\"\"\"\n    try:\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n        \n        transaction = Transaction.query.get(transaction_id)\n        if not transaction:\n            return jsonify({'success': False, 'error': 'Транзакция не найдена'}), 400\n        \n        transaction.status = TransactionStatus.SUSPENDED\n        db.session.commit()\n        \n        # Clear current transaction from session\n        session.pop('current_transaction_id', None)\n        \n        return jsonify({\n            'success': True,\n            'message': f'Чек {transaction.transaction_number} отложен'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/suspended_transactions', methods=['GET'])\n@login_required\ndef get_suspended_transactions():\n    \"\"\"Get list of suspended transactions for current user\"\"\"\n    try:\n        suspended_transactions = Transaction.query.filter_by(\n            status=TransactionStatus.SUSPENDED,\n            user_id=current_user.id\n        ).order_by(Transaction.created_at.desc()).all()\n        \n        transactions_data = []\n        for transaction in suspended_transactions:\n            items_count = len(transaction.items)\n            transactions_data.append({\n                'id': transaction.id,\n                'transaction_number': transaction.transaction_number,\n                'created_at': transaction.created_at.strftime('%d.%m.%Y %H:%M'),\n                'cashier_name': transaction.cashier_name or 'Кассир',\n                'customer_name': transaction.customer_name or '',\n                'total_amount': float(transaction.total_amount),\n                'items_count': items_count\n            })\n        \n        return jsonify({\n            'success': True,\n            'transactions': transactions_data\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/restore', methods=['POST'])\n@login_required\ndef restore_transaction():\n    \"\"\"Restore suspended transaction\"\"\"\n    try:\n        data = request.get_json() or {}\n        transaction_id = data.get('transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Не указан ID транзакции'}), 400\n        \n        # Check if there's already an active transaction\n        current_transaction_id = session.get('current_transaction_id')\n        if current_transaction_id:\n            current_transaction = Transaction.query.get(current_transaction_id)\n            if current_transaction and current_transaction.status == TransactionStatus.PENDING:\n                return jsonify({\n                    'success': False, \n                    'error': 'Завершите или отложите текущую транзакцию перед восстановлением'\n                }), 400\n        \n        transaction = Transaction.query.filter_by(\n            id=transaction_id,\n            user_id=current_user.id\n        ).first()\n        if not transaction:\n            return jsonify({'success': False, 'error': 'Транзакция не найдена или не принадлежит вам'}), 404\n        \n        if transaction.status != TransactionStatus.SUSPENDED:\n            return jsonify({'success': False, 'error': 'Транзакция не отложена'}), 400\n        \n        # Restore transaction\n        transaction.status = TransactionStatus.PENDING\n        db.session.commit()\n        \n        # Set as current transaction\n        session['current_transaction_id'] = transaction.id\n        \n        return jsonify({\n            'success': True,\n            'message': f'Чек {transaction.transaction_number} восстановлен',\n            'transaction_id': transaction.id,\n            'transaction_number': transaction.transaction_number\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/remove_item', methods=['POST'])\ndef remove_item_from_transaction():\n    \"\"\"Remove item from current transaction\"\"\"\n    try:\n        data = request.get_json() or {}\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n        \n        item_id = data.get('item_id')\n        if not item_id:\n            return jsonify({'success': False, 'error': 'Не указан ID товара'}), 400\n        \n        item = TransactionItem.query.filter_by(\n            id=item_id, \n            transaction_id=transaction_id\n        ).first()\n        \n        if not item:\n            return jsonify({'success': False, 'error': 'Товар не найден в корзине'}), 404\n        \n        transaction = item.transaction\n        db.session.delete(item)\n        \n        # Update transaction totals\n        update_transaction_totals(transaction)\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'transaction_total': float(transaction.total_amount)\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/apply_discount', methods=['POST'])\ndef apply_discount():\n    \"\"\"Apply discount to current transaction\"\"\"\n    try:\n        data = request.get_json() or {}\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n        \n        transaction = Transaction.query.get(transaction_id)\n        if not transaction:\n            return jsonify({'success': False, 'error': 'Транзакция не найдена'}), 400\n        \n        discount_type = data.get('type', 'percentage')  # percentage or fixed_amount\n        discount_value = float(data.get('value', 0))\n        \n        if discount_type == 'percentage':\n            discount_amount = transaction.subtotal * (discount_value / 100)\n        else:\n            discount_amount = discount_value\n        \n        # Ensure discount doesn't exceed subtotal\n        discount_amount = min(discount_amount, transaction.subtotal)\n        \n        transaction.discount_amount = discount_amount\n        update_transaction_totals(transaction)\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'discount_amount': float(discount_amount),\n            'total_amount': float(transaction.total_amount),\n            'message': f'Скидка {discount_value}{\"%\" if discount_type == \"percentage\" else \" ₽\"} применена'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/apply_promo', methods=['POST'])\ndef apply_promo_to_transaction():\n    \"\"\"Apply promo code to current transaction with proper atomicity\"\"\"\n    # Check if promo features are enabled\n    if not current_app.config.get('PROMO_FEATURES_ENABLED', False):\n        return jsonify({'success': False, 'error': 'Promo code features not available - database schema incompatible'}), 503\n        \n    if not current_app.config.get('PROMO_CODES_TABLE_EXISTS', False):\n        return jsonify({'success': False, 'error': 'Promo codes table not available'}), 503\n        \n    try:\n        data = request.get_json() or {}\n        code = data.get('code', '').upper().strip()\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n        \n        if not code:\n            return jsonify({'success': False, 'error': 'Промокод не указан'}), 400\n            \n        # Use transaction for atomicity\n        with db.session.begin():\n            # Get and lock the transaction\n            transaction = db.session.query(Transaction).filter_by(id=transaction_id).with_for_update().first()\n            if not transaction or transaction.status != TransactionStatus.PENDING:\n                return jsonify({'success': False, 'error': 'Транзакция недоступна'}), 400\n            \n            # Check if promo already applied\n            if transaction.promo_code_used:\n                return jsonify({'success': False, 'error': 'Промокод уже применен к этой транзакции'}), 400\n            \n            # Get and lock the promo code\n            promo = db.session.query(PromoCode).filter(\n                func.upper(PromoCode.code) == code,\n                PromoCode.is_active == True\n            ).with_for_update().first()\n            \n            if not promo:\n                return jsonify({'success': False, 'error': 'Промокод не найден или не активен'}), 404\n            \n            now = datetime.utcnow()\n            \n            # Validate promo code constraints\n            if promo.start_date and promo.start_date > now:\n                return jsonify({'success': False, 'error': 'Промокод еще не активен'}), 400\n            \n            if promo.end_date and promo.end_date < now:\n                return jsonify({'success': False, 'error': 'Промокод истек'}), 400\n            \n            if promo.max_uses and promo.current_uses >= promo.max_uses:\n                return jsonify({'success': False, 'error': 'Промокод исчерпан'}), 400\n            \n            if transaction.subtotal < promo.min_amount:\n                return jsonify({\n                    'success': False, \n                    'error': f'Минимальная сумма для применения промокода: {float(promo.min_amount)} ₸'\n                }), 400\n            \n            # Calculate discount\n            if promo.discount_type == 'percentage':\n                discount_amount = transaction.subtotal * (promo.discount_value / 100)\n            else:\n                discount_amount = promo.discount_value\n            \n            # Ensure discount doesn't exceed subtotal\n            discount_amount = min(discount_amount, transaction.subtotal)\n            \n            # Apply discount to transaction\n            transaction.discount_amount = discount_amount\n            transaction.promo_code_used = code\n            update_transaction_totals(transaction)\n            \n            # Note: Don't increment usage here - only on successful checkout\n            \n            return jsonify({\n                'success': True,\n                'promo_code': code,\n                'discount_amount': float(discount_amount),\n                'total_amount': float(transaction.total_amount),\n                'message': f'Промокод \"{code}\" применен! Скидка: {float(promo.discount_value)}{\"%\" if promo.discount_type == \"percentage\" else \" ₸\"}'\n            })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@pos_bp.route('/api/transaction/remove_promo', methods=['POST'])\ndef remove_promo_from_transaction():\n    \"\"\"Remove promo code from current transaction\"\"\"\n    # Check if promo features are enabled\n    if not current_app.config.get('PROMO_FEATURES_ENABLED', False):\n        return jsonify({'success': False, 'error': 'Promo code features not available - database schema incompatible'}), 503\n        \n    try:\n        transaction_id = session.get('current_transaction_id')\n        \n        if not transaction_id:\n            return jsonify({'success': False, 'error': 'Нет активной транзакции'}), 400\n            \n        with db.session.begin():\n            transaction = db.session.query(Transaction).filter_by(id=transaction_id).with_for_update().first()\n            if not transaction or transaction.status != TransactionStatus.PENDING:\n                return jsonify({'success': False, 'error': 'Транзакция недоступна'}), 400\n            \n            if not transaction.promo_code_used:\n                return jsonify({'success': False, 'error': 'Промокод не применен'}), 400\n            \n            # Remove discount\n            transaction.discount_amount = Decimal('0.00')\n            transaction.promo_code_used = None\n            update_transaction_totals(transaction)\n            \n            return jsonify({\n                'success': True,\n                'total_amount': float(transaction.total_amount),\n                'message': 'Промокод удален'\n            })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500","size_bytes":36529},"views/inventory.py":{"content":"\"\"\"\nInventory management views for POS system\n\"\"\"\nimport os\nimport json\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom flask import Blueprint, render_template, request, jsonify, session, current_app\nfrom flask_login import login_required, current_user\nfrom sqlalchemy import or_\nfrom models import db, Product, Supplier, Category, DiscountRule, PromoCode, Transaction, UnitType, UserRole\nfrom utils.image_processing import allowed_file, validate_image, generate_unique_filename, process_product_image, delete_product_image\n\n\n# Create the blueprint\ninventory_bp = Blueprint('inventory', __name__)\n\n\ndef require_role(required_role):\n    \"\"\"Decorator to require specific user role\"\"\"\n    def decorator(f):\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                return jsonify({'success': False, 'error': 'Жүйеге кіру қажет / Необходимо войти в систему'}), 401\n            \n            if not current_user.can_access(required_role):\n                return jsonify({'success': False, 'error': 'Бұл әрекетке рұқсат жоқ / Недостаточно прав доступа'}), 403\n            \n            return f(*args, **kwargs)\n        decorated_function.__name__ = f.__name__\n        return decorated_function\n    return decorator\n\n\ndef log_operation(action, description=None, entity_type=None, entity_id=None, old_values=None, new_values=None):\n    \"\"\"Log user operations for audit trail\"\"\"\n    if current_user.is_authenticated:\n        try:\n            from models import OperationLog\n            log_entry = OperationLog()\n            log_entry.action = action\n            log_entry.description = description\n            log_entry.entity_type = entity_type\n            log_entry.entity_id = entity_id\n            log_entry.old_values = json.dumps(old_values) if old_values else None\n            log_entry.new_values = json.dumps(new_values) if new_values else None\n            log_entry.ip_address = request.remote_addr\n            log_entry.user_agent = request.headers.get('User-Agent')\n            log_entry.user_id = current_user.id\n            db.session.add(log_entry)\n            db.session.commit()\n        except Exception as e:\n            print(f\"Failed to log operation: {e}\")\n\n\ndef get_language():\n    \"\"\"Get current language from session\"\"\"\n    return session.get('language', 'kk')  # Default to Kazakh\n\n\ndef translate_name(original_name, category='products'):\n    \"\"\"Translate product/category name based on current language\"\"\"\n    TRANSLATIONS = {\n        'categories': {\n            'Сүт өнімдері': {'kk': 'Сүт өнімдері', 'ru': 'Молочные продукты'},\n            'Нан өнімдері': {'kk': 'Нан өнімдері', 'ru': 'Хлебобулочные'},\n            'Сусындар': {'kk': 'Сусындар', 'ru': 'Напитки'},\n            'Ет өнімдері': {'kk': 'Ет өнімдері', 'ru': 'Мясные продукты'},\n            'Жемістер мен көкөністер': {'kk': 'Жемістер мен көкөністер', 'ru': 'Фрукты и овощи'},\n        },\n        'products': {\n            'Сүт 3.2% 1л': {'kk': 'Сүт 3.2% 1л', 'ru': 'Молоко 3.2% 1л'},\n            'Нан ақ': {'kk': 'Нан ақ', 'ru': 'Хлеб белый'},\n            'Апельсин шырыны 1л': {'kk': 'Апельсин шырыны 1л', 'ru': 'Сок апельсиновый 1л'},\n            'Ірімшік қазақстандық': {'kk': 'Ірімшік қазақстандық', 'ru': 'Сыр казахстанский'},\n            'Алма қызыл': {'kk': 'Алма қызыл', 'ru': 'Яблоки красные'},\n        },\n        'units': {\n            'шт.': {'kk': 'дана', 'ru': 'шт.'},\n            'кг.': {'kk': 'кг.', 'ru': 'кг.'},\n            'л.': {'kk': 'л.', 'ru': 'л.'},\n            'м.': {'kk': 'м.', 'ru': 'м.'},\n            'упак.': {'kk': 'орам', 'ru': 'упак.'},\n        }\n    }\n    \n    translations = TRANSLATIONS.get(category, {})\n    if original_name in translations:\n        return translations[original_name].get(get_language(), original_name)\n    return original_name\n\n\n# Main inventory management page\n@inventory_bp.route('/inventory')\n@login_required\ndef inventory():\n    \"\"\"Inventory management page with advanced filters\"\"\"\n    search = request.args.get('search', '')\n    category_id = request.args.get('category_id')\n    price_range = request.args.get('price_range', '')\n    stock_filter = request.args.get('stock_filter', '')\n    \n    query = Product.query.filter_by(is_active=True)\n    \n    # Text search filter\n    if search:\n        query = query.filter(\n            or_(\n                Product.name.ilike(f'%{search}%'),\n                Product.sku.ilike(f'%{search}%'),\n                Product.description.ilike(f'%{search}%')\n            )\n        )\n    \n    # Category filter\n    if category_id:\n        query = query.filter_by(category_id=category_id)\n    \n    # Price range filter\n    if price_range:\n        if price_range == '0-500':\n            query = query.filter(Product.price.between(0, 500))\n        elif price_range == '500-1000':\n            query = query.filter(Product.price.between(500, 1000))\n        elif price_range == '1000-2000':\n            query = query.filter(Product.price.between(1000, 2000))\n        elif price_range == '2000+':\n            query = query.filter(Product.price >= 2000)\n    \n    # Stock filter\n    if stock_filter:\n        if stock_filter == 'low':\n            query = query.filter(Product.stock_quantity <= Product.min_stock_level)\n        elif stock_filter == 'zero':\n            query = query.filter(Product.stock_quantity == 0)\n        elif stock_filter == 'available':\n            query = query.filter(Product.stock_quantity > 0)\n    \n    # Order by stock status (critical first), then by name\n    products = query.order_by(\n        db.case(\n            (Product.stock_quantity == 0, 0),\n            (Product.stock_quantity <= Product.min_stock_level, 1),\n            else_=2\n        ),\n        Product.name\n    ).all()\n    \n    categories = Category.query.order_by(Category.name).all()\n    suppliers = Supplier.query.filter_by(is_active=True).order_by(Supplier.name).all()\n    \n    # Translate names for current language\n    for product in products:\n        product.translated_name = translate_name(product.name, 'products')\n        product.translated_unit = translate_name(product.unit_type.value, 'units')\n    for category in categories:\n        category.translated_name = translate_name(category.name, 'categories')\n    \n    # Legacy support for show_low_stock parameter\n    show_low_stock = stock_filter == 'low' or request.args.get('low_stock')\n    \n    return render_template('inventory.html', \n                         products=products, \n                         categories=categories,\n                         suppliers=suppliers,\n                         search=search,\n                         selected_category=category_id,\n                         show_low_stock=show_low_stock,\n                         price_range=price_range,\n                         stock_filter=stock_filter)\n\n\n# Product management API endpoints\n@inventory_bp.route('/api/products', methods=['POST'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef create_product():\n    \"\"\"Create new product\"\"\"\n    try:\n        data = request.get_json() or {}\n        \n        # Check if SKU already exists\n        existing_product = Product.query.filter_by(sku=data['sku']).first()\n        if existing_product:\n            return jsonify({'success': False, 'error': 'Товар с таким артикулом уже существует'}), 400\n        \n        product = Product(  # type: ignore\n            sku=data['sku'],\n            name=data['name'],\n            description=data.get('description', ''),\n            unit_type=UnitType(data.get('unit_type', 'шт.')),\n            price=Decimal(str(data['price'])),\n            cost_price=Decimal(str(data.get('cost_price', 0))),\n            stock_quantity=int(data.get('stock_quantity', 0)),\n            min_stock_level=int(data.get('min_stock_level', 0)),\n            supplier_id=data.get('supplier_id'),\n            category_id=data.get('category_id')\n        )\n        \n        db.session.add(product)\n        db.session.commit()\n        \n        log_operation('product_create', f'Product created: {product.name}', 'product', product.id)\n        \n        return jsonify({\n            'success': True,\n            'product_id': product.id,\n            'message': 'Товар успешно создан'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n@inventory_bp.route('/api/products/<int:product_id>', methods=['PUT'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef update_product(product_id):\n    \"\"\"Update existing product\"\"\"\n    try:\n        product = Product.query.get_or_404(product_id)\n        data = request.get_json() or {}\n        \n        # Store old values for logging\n        old_values = {\n            'sku': product.sku,\n            'name': product.name,\n            'price': float(product.price),\n            'stock_quantity': product.stock_quantity\n        }\n        \n        # Check SKU uniqueness if changed\n        if data.get('sku') and data['sku'] != product.sku:\n            existing = Product.query.filter_by(sku=data['sku']).first()\n            if existing:\n                return jsonify({'success': False, 'error': 'Товар с таким артикулом уже существует'}), 400\n        \n        # Update product fields\n        if 'sku' in data:\n            product.sku = data['sku']\n        if 'name' in data:\n            product.name = data['name']\n        if 'description' in data:\n            product.description = data['description']\n        if 'unit_type' in data:\n            product.unit_type = UnitType(data['unit_type'])\n        if 'price' in data:\n            product.price = Decimal(str(data['price']))\n        if 'cost_price' in data:\n            product.cost_price = Decimal(str(data['cost_price']))\n        if 'stock_quantity' in data:\n            product.stock_quantity = int(data['stock_quantity'])\n        if 'min_stock_level' in data:\n            product.min_stock_level = int(data['min_stock_level'])\n        if 'supplier_id' in data:\n            product.supplier_id = data['supplier_id']\n        if 'category_id' in data:\n            product.category_id = data['category_id']\n        \n        product.updated_at = datetime.utcnow()\n        \n        # New values for logging\n        new_values = {\n            'sku': product.sku,\n            'name': product.name,\n            'price': float(product.price),\n            'stock_quantity': product.stock_quantity\n        }\n        \n        db.session.commit()\n        \n        log_operation('product_update', f'Product updated: {product.name}', 'product', product.id, old_values, new_values)\n        \n        return jsonify({\n            'success': True,\n            'message': 'Товар успешно обновлен'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n@inventory_bp.route('/api/products/<int:product_id>/stock', methods=['POST'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef adjust_stock(product_id):\n    \"\"\"Adjust product stock level\"\"\"\n    try:\n        product = Product.query.get_or_404(product_id)\n        data = request.get_json() or {}\n        \n        adjustment = int(data.get('adjustment', 0))\n        reason = data.get('reason', 'Корректировка остатков')\n        \n        old_quantity = product.stock_quantity\n        new_quantity = product.stock_quantity + adjustment\n        if new_quantity < 0:\n            return jsonify({'success': False, 'error': 'Остаток не может быть отрицательным'}), 400\n        \n        product.stock_quantity = new_quantity\n        product.updated_at = datetime.utcnow()\n        \n        db.session.commit()\n        \n        log_operation('stock_adjustment', f'Stock adjusted for {product.name}: {old_quantity} -> {new_quantity} ({reason})', 'product', product.id)\n        \n        return jsonify({\n            'success': True,\n            'new_quantity': product.stock_quantity,\n            'message': f'Остаток обновлен: {adjustment:+d} ({reason})'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n# Image management API endpoints\n@inventory_bp.route('/api/products/<int:product_id>/upload-image', methods=['POST'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef upload_product_image(product_id):\n    \"\"\"Upload image for product\"\"\"\n    try:\n        product = Product.query.get_or_404(product_id)\n        \n        # Check if file was uploaded\n        if 'image' not in request.files:\n            return jsonify({'success': False, 'error': 'Файл не выбран'}), 400\n            \n        file = request.files['image']\n        \n        # Validate the uploaded file\n        is_valid, message = validate_image(file)\n        if not is_valid:\n            return jsonify({'success': False, 'error': message}), 400\n        \n        # Generate unique filename\n        filename = generate_unique_filename(file.filename)\n        \n        # Delete old image if exists\n        if product.image_filename:\n            delete_product_image(product.image_filename)\n        \n        # Process and save the new image\n        success, result = process_product_image(file, filename)\n        if not success:\n            return jsonify({'success': False, 'error': result}), 500\n        \n        # Update product record\n        product.image_filename = filename\n        product.updated_at = datetime.utcnow()\n        db.session.commit()\n        \n        log_operation('product_image_upload', f'Image uploaded for product: {product.name}', 'product', product.id)\n        \n        return jsonify({\n            'success': True,\n            'message': 'Изображение успешно загружено',\n            'image_filename': filename,\n            'image_url': f'/static/images/products/{filename}',\n            'thumbnail_url': f'/static/images/products/thumbnails/{filename}'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n@inventory_bp.route('/api/products/<int:product_id>/delete-image', methods=['DELETE'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef delete_product_image_api(product_id):\n    \"\"\"Delete product image\"\"\"\n    try:\n        product = Product.query.get_or_404(product_id)\n        \n        if not product.image_filename:\n            return jsonify({'success': False, 'error': 'У товара нет изображения'}), 400\n        \n        # Delete image files\n        delete_product_image(product.image_filename)\n        \n        # Update product record\n        old_filename = product.image_filename\n        product.image_filename = None\n        product.updated_at = datetime.utcnow()\n        db.session.commit()\n        \n        log_operation('product_image_delete', f'Image deleted for product: {product.name}', 'product', product.id)\n        \n        return jsonify({\n            'success': True,\n            'message': 'Изображение успешно удалено'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n# Category and supplier management API endpoints\n@inventory_bp.route('/api/categories', methods=['POST'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef create_category():\n    \"\"\"Create new category\"\"\"\n    try:\n        data = request.get_json() or {}\n        \n        # Check if category already exists\n        existing_category = Category.query.filter_by(name=data['name']).first()\n        if existing_category:\n            return jsonify({'success': False, 'error': 'Категория с таким названием уже существует'}), 400\n        \n        category = Category(  # type: ignore\n            name=data['name'],\n            description=data.get('description', '')\n        )\n        \n        db.session.add(category)\n        db.session.commit()\n        \n        log_operation('category_create', f'Category created: {category.name}', 'category', category.id)\n        \n        return jsonify({\n            'success': True,\n            'category_id': category.id,\n            'message': 'Категория успешно создана'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n@inventory_bp.route('/api/suppliers', methods=['POST'])\n@login_required\n@require_role(UserRole.MANAGER)\ndef create_supplier():\n    \"\"\"Create new supplier\"\"\"\n    try:\n        data = request.get_json() or {}\n        \n        # Check if supplier already exists\n        existing_supplier = Supplier.query.filter_by(name=data['name']).first()\n        if existing_supplier:\n            return jsonify({'success': False, 'error': 'Поставщик с таким названием уже существует'}), 400\n        \n        supplier = Supplier(  # type: ignore\n            name=data['name'],\n            contact_person=data.get('contact_person', ''),\n            phone=data.get('phone', ''),\n            email=data.get('email', ''),\n            address=data.get('address', '')\n        )\n        \n        db.session.add(supplier)\n        db.session.commit()\n        \n        log_operation('supplier_create', f'Supplier created: {supplier.name}', 'supplier', supplier.id)\n        \n        return jsonify({\n            'success': True,\n            'supplier_id': supplier.id,\n            'message': 'Поставщик успешно создан'\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n\n# Discount and promo code API endpoints\n@inventory_bp.route('/api/discount_rules')\n@login_required\ndef get_discount_rules():\n    \"\"\"Get active discount rules\"\"\"\n    now = datetime.utcnow()\n    rules = DiscountRule.query.filter(\n        DiscountRule.is_active == True,\n        or_(\n            DiscountRule.start_date.is_(None),\n            DiscountRule.start_date <= now\n        ),\n        or_(\n            DiscountRule.end_date.is_(None),\n            DiscountRule.end_date >= now\n        )\n    ).all()\n    \n    return jsonify([{\n        'id': rule.id,\n        'name': rule.name,\n        'description': rule.description,\n        'discount_type': rule.discount_type,\n        'discount_value': float(rule.discount_value),\n        'min_amount': float(rule.min_amount),\n        'category_name': rule.category.name if rule.category else None\n    } for rule in rules])\n\n\n@inventory_bp.route('/api/promo_code/validate', methods=['POST'])\n@login_required\ndef validate_promo_code():\n    \"\"\"Validate promo code\"\"\"\n    try:\n        data = request.get_json() or {}\n        code = data.get('code', '').upper().strip()\n        \n        if not code:\n            return jsonify({'success': False, 'error': 'Промокод не указан'}), 400\n        \n        # Find promo code\n        promo = PromoCode.query.filter_by(code=code, is_active=True).first()\n        if not promo:\n            return jsonify({'success': False, 'error': 'Промокод не найден или не активен'}), 404\n        \n        now = datetime.utcnow()\n        \n        # Check date validity\n        if promo.start_date and promo.start_date > now:\n            return jsonify({'success': False, 'error': 'Промокод еще не активен'}), 400\n        \n        if promo.end_date and promo.end_date < now:\n            return jsonify({'success': False, 'error': 'Промокод истек'}), 400\n        \n        # Check usage limit\n        if promo.max_uses and promo.current_uses >= promo.max_uses:\n            return jsonify({'success': False, 'error': 'Промокод исчерпан'}), 400\n        \n        # Check minimum amount (if transaction exists)\n        transaction_id = session.get('current_transaction_id')\n        if transaction_id:\n            transaction = Transaction.query.get(transaction_id)\n            if transaction and transaction.subtotal < promo.min_amount:\n                return jsonify({\n                    'success': False, \n                    'error': f'Минимальная сумма для применения промокода: {float(promo.min_amount)} ₸'\n                }), 400\n        \n        return jsonify({\n            'success': True,\n            'promo_code': {\n                'id': promo.id,\n                'code': promo.code,\n                'name': promo.name,\n                'description': promo.description,\n                'discount_type': promo.discount_type,\n                'discount_value': float(promo.discount_value),\n                'min_amount': float(promo.min_amount)\n            }\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500","size_bytes":21487},"services/analytics_service.py":{"content":"\"\"\"\nAnalytics and reporting business logic service\n\"\"\"\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func, desc, text\nfrom models import db, Transaction, TransactionItem, Product, Category, Supplier, TransactionStatus\n\n\nclass AnalyticsService:\n    \"\"\"Service for handling analytics and reporting business logic\"\"\"\n    \n    @staticmethod\n    def get_sales_summary(start_date=None, end_date=None):\n        \"\"\"Get sales summary for date range\"\"\"\n        if not start_date:\n            start_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)\n        if not end_date:\n            end_date = datetime.now()\n        \n        # Get total sales\n        total_sales = db.session.query(\n            func.sum(Transaction.total_amount)\n        ).filter(\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at.between(start_date, end_date)\n        ).scalar() or 0\n        \n        # Get transaction count\n        transaction_count = Transaction.query.filter(\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at.between(start_date, end_date)\n        ).count()\n        \n        # Get average transaction value\n        avg_transaction = total_sales / transaction_count if transaction_count > 0 else 0\n        \n        return {\n            'total_sales': float(total_sales),\n            'transaction_count': transaction_count,\n            'avg_transaction_value': float(avg_transaction),\n            'period_start': start_date,\n            'period_end': end_date\n        }\n    \n    @staticmethod\n    def get_top_products(limit=10, start_date=None, end_date=None):\n        \"\"\"Get top selling products\"\"\"\n        if not start_date:\n            start_date = datetime.now() - timedelta(days=30)\n        if not end_date:\n            end_date = datetime.now()\n        \n        top_products = db.session.query(\n            Product.id,\n            Product.name,\n            Product.price,\n            Product.cost_price,\n            func.sum(TransactionItem.quantity).label('total_sold'),\n            func.sum(TransactionItem.total_price).label('total_revenue'),\n            func.sum((Product.price - Product.cost_price) * TransactionItem.quantity).label('total_profit')\n        ).join(\n            TransactionItem, Product.id == TransactionItem.product_id\n        ).join(\n            Transaction, TransactionItem.transaction_id == Transaction.id\n        ).filter(\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at.between(start_date, end_date)\n        ).group_by(\n            Product.id, Product.name, Product.price, Product.cost_price\n        ).order_by(\n            desc('total_sold')\n        ).limit(limit).all()\n        \n        return [{\n            'id': row.id,\n            'name': row.name,\n            'price': float(row.price),\n            'cost_price': float(row.cost_price),\n            'total_sold': float(row.total_sold),\n            'total_revenue': float(row.total_revenue),\n            'total_profit': float(row.total_profit),\n            'avg_profit_per_unit': float(row.total_profit / row.total_sold) if row.total_sold > 0 else 0\n        } for row in top_products]\n    \n    @staticmethod\n    def get_category_analysis(start_date=None, end_date=None):\n        \"\"\"Get sales analysis by category\"\"\"\n        if not start_date:\n            start_date = datetime.now() - timedelta(days=30)\n        if not end_date:\n            end_date = datetime.now()\n        \n        category_analysis = db.session.query(\n            Category.name,\n            func.sum(TransactionItem.total_price).label('total_revenue'),\n            func.sum((Product.price - Product.cost_price) * TransactionItem.quantity).label('total_profit'),\n            func.count(TransactionItem.id).label('total_transactions')\n        ).join(\n            Product, Category.id == Product.category_id\n        ).join(\n            TransactionItem, Product.id == TransactionItem.product_id\n        ).join(\n            Transaction, TransactionItem.transaction_id == Transaction.id\n        ).filter(\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at.between(start_date, end_date)\n        ).group_by(\n            Category.name\n        ).order_by(\n            desc('total_revenue')\n        ).all()\n        \n        return [{\n            'name': row.name,\n            'total_revenue': float(row.total_revenue),\n            'total_profit': float(row.total_profit),\n            'total_transactions': int(row.total_transactions)\n        } for row in category_analysis]\n    \n    @staticmethod\n    def get_daily_sales(days=30):\n        \"\"\"Get daily sales for the last N days\"\"\"\n        start_date = datetime.now() - timedelta(days=days)\n        \n        daily_sales = db.session.query(\n            func.date(Transaction.completed_at).label('date'),\n            func.sum(Transaction.total_amount).label('total_revenue'),\n            func.sum(Transaction.total_amount - Transaction.subtotal + \n                    func.coalesce(func.sum(\n                        (Product.price - Product.cost_price) * TransactionItem.quantity\n                    ), 0)).label('total_profit'),\n            func.count(Transaction.id).label('transaction_count')\n        ).join(\n            TransactionItem, Transaction.id == TransactionItem.transaction_id\n        ).join(\n            Product, TransactionItem.product_id == Product.id\n        ).filter(\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at >= start_date\n        ).group_by(\n            func.date(Transaction.completed_at)\n        ).order_by(\n            func.date(Transaction.completed_at)\n        ).all()\n        \n        return [{\n            'date': row.date.strftime('%Y-%m-%d'),\n            'total_revenue': float(row.total_revenue),\n            'total_profit': float(row.total_profit or 0),\n            'transaction_count': int(row.transaction_count)\n        } for row in daily_sales]\n    \n    @staticmethod\n    def get_inventory_report():\n        \"\"\"Get inventory status report\"\"\"\n        inventory_report = db.session.query(\n            Product.id,\n            Product.name,\n            Product.sku,\n            Product.stock_quantity,\n            Product.min_stock_level,\n            Product.price,\n            Product.cost_price,\n            Category.name.label('category_name'),\n            Supplier.name.label('supplier_name')\n        ).join(\n            Category, Product.category_id == Category.id\n        ).join(\n            Supplier, Product.supplier_id == Supplier.id\n        ).filter(\n            Product.is_active == True\n        ).order_by(\n            Product.name\n        ).all()\n        \n        return [{\n            'id': row.id,\n            'name': row.name,\n            'sku': row.sku,\n            'stock_quantity': int(row.stock_quantity),\n            'min_stock_level': int(row.min_stock_level),\n            'price': float(row.price),\n            'cost_price': float(row.cost_price),\n            'profit_margin': float((row.price - row.cost_price) / row.price * 100) if row.price > 0 else 0,\n            'category_name': row.category_name,\n            'supplier_name': row.supplier_name,\n            'stock_status': 'low' if row.stock_quantity <= row.min_stock_level else 'normal'\n        } for row in inventory_report]\n    \n    @staticmethod\n    def get_low_stock_products():\n        \"\"\"Get products with low stock\"\"\"\n        low_stock = Product.query.filter(\n            Product.stock_quantity <= Product.min_stock_level,\n            Product.is_active == True\n        ).order_by(\n            Product.stock_quantity\n        ).all()\n        \n        return [{\n            'id': product.id,\n            'name': product.name,\n            'sku': product.sku,\n            'stock_quantity': product.stock_quantity,\n            'min_stock_level': product.min_stock_level,\n            'shortage': product.min_stock_level - product.stock_quantity\n        } for product in low_stock]","size_bytes":8062},"services/product_service.py":{"content":"\"\"\"\nProduct and inventory business logic service\n\"\"\"\nfrom models import db, Product, Category, Supplier, Transaction, TransactionItem, TransactionStatus\nfrom sqlalchemy import or_, desc, func\nfrom utils.helpers import log_operation\nfrom utils.image_processing import process_product_image, delete_product_image, generate_unique_filename\nfrom utils.language import translate_name, get_language\n\n\nclass ProductService:\n    \"\"\"Service for handling product and inventory business logic\"\"\"\n    \n    @staticmethod\n    def search_products(query='', category_id=None, limit=20):\n        \"\"\"Search products with filters\"\"\"\n        products_query = Product.query.filter_by(is_active=True)\n        \n        if query:\n            products_query = products_query.filter(\n                or_(\n                    Product.name.ilike(f'%{query}%'),\n                    Product.sku.ilike(f'%{query}%'),\n                    Product.barcode.ilike(f'%{query}%')\n                )\n            )\n        \n        if category_id:\n            products_query = products_query.filter_by(category_id=category_id)\n        \n        products = products_query.limit(min(limit, 50)).all()\n        \n        # Translate product names for current language\n        for product in products:\n            product.translated_name = translate_name(product.name)\n        \n        return products\n    \n    @staticmethod\n    def search_by_barcode(barcode):\n        \"\"\"Search product by barcode\"\"\"\n        if not barcode:\n            return None\n        \n        product = Product.query.filter_by(barcode=barcode, is_active=True).first()\n        if product:\n            product.translated_name = translate_name(product.name)\n        \n        return product\n    \n    @staticmethod\n    def get_popular_products(limit=10, days=30):\n        \"\"\"Get popular products based on sales\"\"\"\n        from datetime import datetime, timedelta\n        \n        # Calculate date range\n        start_date = datetime.now() - timedelta(days=days)\n        \n        # Query for popular products based on transaction items\n        popular_products = db.session.query(\n            Product.id,\n            Product.name,\n            Product.price,\n            Product.stock_quantity,\n            func.sum(TransactionItem.quantity).label('total_sold'),\n            func.count(TransactionItem.id).label('transaction_count')\n        ).join(\n            TransactionItem, Product.id == TransactionItem.product_id\n        ).join(\n            Transaction, TransactionItem.transaction_id == Transaction.id\n        ).filter(\n            Transaction.status == TransactionStatus.COMPLETED,\n            Transaction.completed_at >= start_date,\n            Product.is_active == True\n        ).group_by(\n            Product.id, Product.name, Product.price, Product.stock_quantity\n        ).order_by(\n            desc('total_sold')\n        ).limit(limit).all()\n        \n        return popular_products\n    \n    @staticmethod\n    def create_product(data):\n        \"\"\"Create new product\"\"\"\n        # Validate required fields\n        required_fields = ['name', 'price', 'category_id', 'supplier_id']\n        for field in required_fields:\n            if not data.get(field):\n                raise ValueError(f'Поле {field} обязательно')\n        \n        # Check if SKU already exists\n        if data.get('sku') and Product.query.filter_by(sku=data['sku']).first():\n            raise ValueError('SKU уже существует')\n        \n        # Check if barcode already exists\n        if data.get('barcode') and Product.query.filter_by(barcode=data['barcode']).first():\n            raise ValueError('Штрихкод уже существует')\n        \n        product = Product()\n        for key, value in data.items():\n            if hasattr(product, key):\n                setattr(product, key, value)\n        \n        db.session.add(product)\n        db.session.commit()\n        \n        log_operation('product_create', f'Product created: {product.name}', 'product', product.id)\n        \n        return product\n    \n    @staticmethod\n    def update_product(product_id, data):\n        \"\"\"Update existing product\"\"\"\n        product = Product.query.get(product_id)\n        if not product:\n            raise ValueError('Товар не найден')\n        \n        # Store old values for logging\n        old_values = {\n            'name': product.name,\n            'price': float(product.price),\n            'stock_quantity': product.stock_quantity\n        }\n        \n        # Update product fields\n        for key, value in data.items():\n            if hasattr(product, key) and key != 'id':\n                setattr(product, key, value)\n        \n        db.session.commit()\n        \n        # Store new values for logging\n        new_values = {\n            'name': product.name,\n            'price': float(product.price),\n            'stock_quantity': product.stock_quantity\n        }\n        \n        log_operation('product_update', f'Product updated: {product.name}', 'product', product.id, old_values, new_values)\n        \n        return product\n    \n    @staticmethod\n    def update_stock(product_id, quantity, operation='set'):\n        \"\"\"Update product stock\"\"\"\n        product = Product.query.get(product_id)\n        if not product:\n            raise ValueError('Товар не найден')\n        \n        old_stock = product.stock_quantity\n        \n        if operation == 'add':\n            product.stock_quantity += quantity\n        elif operation == 'subtract':\n            if product.stock_quantity < quantity:\n                raise ValueError('Недостаточно товара на складе')\n            product.stock_quantity -= quantity\n        else:  # set\n            product.stock_quantity = quantity\n        \n        db.session.commit()\n        \n        log_operation(\n            'inventory_update',\n            f'Stock updated for {product.name}: {old_stock} -> {product.stock_quantity}',\n            'product',\n            product.id,\n            {'stock_quantity': old_stock},\n            {'stock_quantity': product.stock_quantity}\n        )\n        \n        return product\n    \n    @staticmethod\n    def upload_product_image(product_id, file):\n        \"\"\"Upload and process product image\"\"\"\n        product = Product.query.get(product_id)\n        if not product:\n            raise ValueError('Товар не найден')\n        \n        # Generate unique filename\n        filename = generate_unique_filename(file.filename)\n        \n        # Process and save image\n        success, result = process_product_image(file, filename)\n        if not success:\n            raise ValueError(result)\n        \n        # Delete old image if exists\n        if product.image_filename:\n            delete_product_image(product.image_filename)\n        \n        # Update product with new image\n        product.image_filename = filename\n        db.session.commit()\n        \n        log_operation('product_image_upload', f'Image uploaded for {product.name}', 'product', product.id)\n        \n        return product\n    \n    @staticmethod\n    def delete_product_image(product_id):\n        \"\"\"Delete product image\"\"\"\n        product = Product.query.get(product_id)\n        if not product:\n            raise ValueError('Товар не найден')\n        \n        if product.image_filename:\n            delete_product_image(product.image_filename)\n            product.image_filename = None\n            db.session.commit()\n            \n            log_operation('product_image_delete', f'Image deleted for {product.name}', 'product', product.id)\n        \n        return product","size_bytes":7633},"services/transaction_service.py":{"content":"\"\"\"\nTransaction business logic service\n\"\"\"\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom flask import session\nfrom flask_login import current_user\nfrom models import db, Transaction, TransactionItem, Product, TransactionStatus, PaymentMethod, Payment, PromoCode\nfrom sqlalchemy import func\nfrom utils.helpers import generate_transaction_number, log_operation\n\n\nclass TransactionService:\n    \"\"\"Service for handling transaction business logic\"\"\"\n    \n    @staticmethod\n    def start_transaction(cashier_name='Кассир', customer_name=''):\n        \"\"\"Start a new transaction\"\"\"\n        transaction = Transaction()\n        transaction.transaction_number = generate_transaction_number()\n        transaction.status = TransactionStatus.PENDING\n        transaction.cashier_name = cashier_name\n        transaction.customer_name = customer_name\n        transaction.user_id = current_user.id if current_user.is_authenticated else None\n        \n        db.session.add(transaction)\n        db.session.commit()\n        \n        # Store transaction ID in session\n        session['current_transaction_id'] = transaction.id\n        \n        return transaction\n    \n    @staticmethod\n    def add_item_to_transaction(transaction_id, product_id, quantity):\n        \"\"\"Add item to transaction with stock validation\"\"\"\n        transaction = Transaction.query.get(transaction_id)\n        if not transaction or transaction.status != TransactionStatus.PENDING:\n            raise ValueError('Транзакция недоступна')\n        \n        product = Product.query.get(product_id)\n        if not product:\n            raise ValueError('Товар не найден')\n        \n        quantity = Decimal(str(quantity))\n        if quantity <= 0:\n            raise ValueError('Неверное количество')\n        \n        # Check stock\n        if product.stock_quantity < float(quantity):\n            raise ValueError('Недостаточно товара на складе')\n        \n        # Create new item\n        item = TransactionItem()\n        item.transaction_id = transaction_id\n        item.product_id = product.id\n        item.quantity = quantity\n        item.unit_price = product.price\n        item.total_price = quantity * product.price\n        item.discount_amount = Decimal('0.00')\n        db.session.add(item)\n        \n        # Update transaction totals\n        TransactionService.update_transaction_totals(transaction)\n        db.session.commit()\n        \n        return item, transaction\n    \n    @staticmethod\n    def update_transaction_totals(transaction):\n        \"\"\"Update transaction totals based on items\"\"\"\n        if not transaction.items:\n            transaction.subtotal = Decimal('0.00')\n            transaction.discount_amount = Decimal('0.00')\n            transaction.tax_amount = Decimal('0.00')\n            transaction.total_amount = Decimal('0.00')\n            return\n        \n        # Calculate subtotal from items\n        subtotal = sum(item.total_price - item.discount_amount for item in transaction.items)\n        \n        # Apply transaction-level discount\n        discount_amount = transaction.discount_amount or Decimal('0.00')\n        \n        # Calculate after discount\n        after_discount = subtotal - discount_amount\n        \n        # Calculate tax (12% VAT for Kazakhstan)\n        tax_rate = Decimal('0.12')  # 12% VAT\n        tax_amount = after_discount * tax_rate\n        \n        # Calculate total\n        total_amount = after_discount + tax_amount\n        \n        transaction.subtotal = subtotal\n        transaction.tax_amount = tax_amount\n        transaction.total_amount = total_amount\n    \n    @staticmethod\n    def complete_transaction(transaction_id, payments):\n        \"\"\"Complete transaction with payments and stock updates\"\"\"\n        transaction = Transaction.query.get(transaction_id)\n        if not transaction or transaction.status != TransactionStatus.PENDING:\n            raise ValueError('Транзакция недоступна')\n        \n        # Validate payment amounts\n        total_payment = sum(Decimal(str(p['amount'])) for p in payments)\n        if abs(total_payment - transaction.total_amount) > Decimal('0.01'):\n            raise ValueError('Сумма оплаты не совпадает с общей суммой')\n        \n        # Create payment records\n        for payment_data in payments:\n            payment = Payment()\n            payment.transaction_id = transaction.id\n            payment.method = PaymentMethod(payment_data['method'])\n            payment.amount = Decimal(str(payment_data['amount']))\n            payment.reference_number = payment_data.get('reference_number')\n            db.session.add(payment)\n        \n        # Update stock quantities\n        for item in transaction.items:\n            item.product.stock_quantity -= int(item.quantity)\n        \n        # Handle promo code usage increment if promo code was used\n        if transaction.promo_code_used:\n            promo = db.session.query(PromoCode).filter(\n                func.upper(PromoCode.code) == transaction.promo_code_used.upper(),\n                PromoCode.is_active == True\n            ).with_for_update().first()\n            \n            if promo:\n                if promo.max_uses and promo.current_uses >= promo.max_uses:\n                    raise ValueError('Промокод исчерпан на момент завершения транзакции')\n                promo.current_uses += 1\n        \n        # Complete transaction\n        transaction.status = TransactionStatus.COMPLETED\n        transaction.completed_at = datetime.utcnow()\n        transaction.user_id = current_user.id if current_user.is_authenticated else None\n        \n        db.session.commit()\n        \n        # Log the completed sale\n        log_operation(\n            'sale_completed',\n            f'Transaction {transaction.transaction_number} completed for ₸{transaction.total_amount}',\n            'transaction',\n            transaction.id,\n            None,\n            {\n                'transaction_number': transaction.transaction_number,\n                'total_amount': float(transaction.total_amount),\n                'items_count': len(transaction.items),\n                'payment_methods': [p['method'] for p in payments]\n            }\n        )\n        \n        # Clear current transaction from session\n        session.pop('current_transaction_id', None)\n        \n        return transaction\n    \n    @staticmethod\n    def suspend_transaction(transaction_id):\n        \"\"\"Suspend current transaction\"\"\"\n        transaction = Transaction.query.get(transaction_id)\n        if not transaction or transaction.status != TransactionStatus.PENDING:\n            raise ValueError('Транзакция недоступна')\n        \n        transaction.status = TransactionStatus.SUSPENDED\n        db.session.commit()\n        \n        # Clear current transaction from session\n        session.pop('current_transaction_id', None)\n        \n        return transaction\n    \n    @staticmethod\n    def restore_transaction(transaction_id):\n        \"\"\"Restore suspended transaction\"\"\"\n        transaction = Transaction.query.get(transaction_id)\n        if not transaction or transaction.status != TransactionStatus.SUSPENDED:\n            raise ValueError('Транзакция недоступна для восстановления')\n        \n        transaction.status = TransactionStatus.PENDING\n        db.session.commit()\n        \n        # Set as current transaction\n        session['current_transaction_id'] = transaction.id\n        \n        return transaction","size_bytes":7647},"views/reports.py":{"content":"from flask import Blueprint, render_template, request, jsonify, send_file, session, flash, redirect, url_for\nfrom flask_login import login_required, current_user\nfrom models import db, Product, Supplier, Category, Transaction, TransactionItem, Payment, User\nfrom models import PaymentMethod, TransactionStatus, UnitType, UserRole\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import desc, func\nimport io\nimport pandas as pd\nfrom reportlab.lib.pagesizes import letter, A4\nfrom reportlab.lib import colors\nfrom reportlab.lib.units import inch\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\n\nreports_bp = Blueprint('reports', __name__)\n\ndef require_role(required_role):\n    \"\"\"Decorator to require specific user role\"\"\"\n    def decorator(f):\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                flash('Жүйеге кіру қажет / Необходимо войти в систему', 'error')\n                return redirect(url_for('login'))\n            \n            if not current_user.can_access(required_role):\n                flash('Бұл әрекетке рұқсат жоқ / Недостаточно прав доступа', 'error')\n                return redirect(url_for('index'))\n            \n            return f(*args, **kwargs)\n        decorated_function.__name__ = f.__name__\n        return decorated_function\n    return decorator\n\n@reports_bp.route('/reports')\n@login_required\ndef reports():\n    \"\"\"Enhanced reports and analytics page\"\"\"\n    # Date range filter\n    start_date = request.args.get('start_date')\n    end_date = request.args.get('end_date')\n    report_type = request.args.get('type', 'overview')  # overview, profit, categories, inventory\n    \n    if not start_date:\n        start_date = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')\n    if not end_date:\n        end_date = datetime.now().strftime('%Y-%m-%d')\n    \n    # Sales by day with profit calculation\n    daily_sales = db.session.query(\n        func.date(Transaction.created_at).label('date'),\n        func.sum(Transaction.total_amount).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit')\n    ).select_from(Transaction).join(\n        TransactionItem, Transaction.id == TransactionItem.transaction_id\n    ).join(\n        Product, TransactionItem.product_id == Product.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(func.date(Transaction.created_at)).all()\n    \n    # Monthly aggregation for longer periods (database-agnostic using extract)\n    monthly_sales = db.session.query(\n        func.concat(\n            func.extract('year', Transaction.created_at), \n            '-', \n            func.lpad(func.extract('month', Transaction.created_at).cast(db.String), 2, '0')\n        ).label('month'),\n        func.sum(Transaction.total_amount).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit')\n    ).select_from(Transaction).join(\n        TransactionItem, Transaction.id == TransactionItem.transaction_id\n    ).join(\n        Product, TransactionItem.product_id == Product.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(\n        func.extract('year', Transaction.created_at),\n        func.extract('month', Transaction.created_at)\n    ).all()\n    \n    # Top selling products with profit\n    top_products = db.session.query(\n        Product.name,\n        func.sum(TransactionItem.quantity).label('total_sold'),\n        func.sum(TransactionItem.total_price).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit'),\n        func.avg(Product.price - Product.cost_price).label('avg_profit_per_unit')\n    ).select_from(Product).join(\n        TransactionItem, Product.id == TransactionItem.product_id\n    ).join(\n        Transaction, TransactionItem.transaction_id == Transaction.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(Product.id, Product.name).order_by(desc('total_sold')).limit(10).all()\n    \n    # Category analysis - most popular categories\n    category_analysis = db.session.query(\n        Category.name,\n        func.count(TransactionItem.id).label('total_transactions'),\n        func.sum(TransactionItem.quantity).label('total_sold'),\n        func.sum(TransactionItem.total_price).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit')\n    ).select_from(Category).join(\n        Product, Category.id == Product.category_id\n    ).join(\n        TransactionItem, Product.id == TransactionItem.product_id\n    ).join(\n        Transaction, TransactionItem.transaction_id == Transaction.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(Category.id, Category.name).order_by(desc('total_revenue')).all()\n    \n    # Inventory analysis\n    inventory_report = db.session.query(\n        Product.name,\n        Product.sku,\n        Product.stock_quantity,\n        Product.min_stock_level,\n        Product.price,\n        Product.cost_price,\n        Category.name.label('category_name'),\n        Supplier.name.label('supplier_name')\n    ).select_from(Product).join(\n        Category, Product.category_id == Category.id\n    ).join(\n        Supplier, Product.supplier_id == Supplier.id\n    ).filter(\n        Product.is_active == True\n    ).order_by(Product.stock_quantity.asc()).all()\n    \n    # Convert Row objects to dictionaries for JSON serialization\n    daily_sales = [{\n        'date': str(row.date),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0)\n    } for row in daily_sales]\n    \n    monthly_sales = [{\n        'month': str(row.month),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0)\n    } for row in monthly_sales]\n    \n    top_products = [{\n        'name': row.name,\n        'total_sold': float(row.total_sold or 0),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0),\n        'avg_profit_per_unit': float(row.avg_profit_per_unit or 0)\n    } for row in top_products]\n    \n    category_analysis = [{\n        'name': row.name,\n        'total_transactions': int(row.total_transactions or 0),\n        'total_sold': float(row.total_sold or 0),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0)\n    } for row in category_analysis]\n    \n    inventory_report = [{\n        'name': row.name,\n        'sku': row.sku,\n        'stock_quantity': int(row.stock_quantity or 0),\n        'min_stock_level': int(row.min_stock_level or 0),\n        'price': float(row.price or 0),\n        'cost_price': float(row.cost_price or 0),\n        'category_name': row.category_name,\n        'supplier_name': row.supplier_name\n    } for row in inventory_report]\n    \n    # Low stock items\n    low_stock_items = [item for item in inventory_report if item['stock_quantity'] <= item['min_stock_level']]\n    \n    # Calculate key metrics\n    total_revenue = sum(sale['total_revenue'] or 0 for sale in daily_sales)\n    total_profit = sum(sale['total_profit'] or 0 for sale in daily_sales)\n    profit_margin = (total_profit / total_revenue * 100) if total_revenue > 0 else 0\n    \n    return render_template('reports.html',\n                         daily_sales=daily_sales,\n                         monthly_sales=monthly_sales,\n                         top_products=top_products,\n                         category_analysis=category_analysis,\n                         inventory_report=inventory_report,\n                         low_stock_items=low_stock_items,\n                         total_revenue=total_revenue,\n                         total_profit=total_profit,\n                         profit_margin=profit_margin,\n                         start_date=start_date,\n                         end_date=end_date,\n                         report_type=report_type)\n\n@reports_bp.route('/export/pdf', methods=['POST'])\n@login_required\ndef export_pdf():\n    \"\"\"Export reports as PDF\"\"\"\n    try:\n        # Get the same data as reports route\n        start_date = request.args.get('start_date')\n        end_date = request.args.get('end_date')\n        \n        if not start_date:\n            start_date = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')\n        if not end_date:\n            end_date = datetime.now().strftime('%Y-%m-%d')\n        \n        # Get analytics data\n        daily_sales, category_analysis, top_products, inventory_report = get_reports_data(start_date, end_date)\n        \n        # Create PDF\n        buffer = io.BytesIO()\n        doc = SimpleDocTemplate(buffer, pagesize=A4)\n        styles = getSampleStyleSheet()\n        story = []\n        \n        # Title\n        title_style = ParagraphStyle(\n            'CustomTitle',\n            parent=styles['Heading1'],\n            fontSize=18,\n            spaceAfter=30,\n            alignment=1  # Center\n        )\n        story.append(Paragraph(f'POS System Analytics Report', title_style))\n        story.append(Paragraph(f'Period: {start_date} to {end_date}', styles['Normal']))\n        story.append(Spacer(1, 20))\n        \n        # Daily Sales Table\n        if daily_sales:\n            story.append(Paragraph('Daily Sales and Profit', styles['Heading2']))\n            sales_data = [['Date', 'Revenue (₸)', 'Profit (₸)']]\n            for sale in daily_sales:\n                sales_data.append([\n                    str(sale['date']),\n                    f\"{sale['total_revenue'] or 0:.2f}\",\n                    f\"{sale['total_profit'] or 0:.2f}\"\n                ])\n            \n            sales_table = Table(sales_data)\n            sales_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                ('FONTSIZE', (0, 0), (-1, 0), 14),\n                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                ('GRID', (0, 0), (-1, -1), 1, colors.black)\n            ]))\n            story.append(sales_table)\n            story.append(Spacer(1, 20))\n        \n        # Top Products Table\n        if top_products:\n            story.append(Paragraph('Top Selling Products', styles['Heading2']))\n            products_data = [['Product', 'Sold', 'Revenue (₸)', 'Profit (₸)']]\n            for product in top_products:\n                products_data.append([\n                    product['name'],\n                    f\"{product['total_sold']:.0f}\",\n                    f\"{product['total_revenue']:.2f}\",\n                    f\"{product['total_profit'] or 0:.2f}\"\n                ])\n            \n            products_table = Table(products_data)\n            products_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                ('FONTSIZE', (0, 0), (-1, 0), 12),\n                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                ('GRID', (0, 0), (-1, -1), 1, colors.black)\n            ]))\n            story.append(products_table)\n            story.append(Spacer(1, 20))\n        \n        # Category Analysis Table\n        if category_analysis:\n            story.append(Paragraph('Category Analysis', styles['Heading2']))\n            category_data = [['Category', 'Transactions', 'Revenue (₸)', 'Profit (₸)']]\n            for category in category_analysis:\n                category_data.append([\n                    category['name'],\n                    str(category['total_transactions']),\n                    f\"{category['total_revenue']:.2f}\",\n                    f\"{category['total_profit'] or 0:.2f}\"\n                ])\n            \n            category_table = Table(category_data)\n            category_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                ('FONTSIZE', (0, 0), (-1, 0), 12),\n                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n                ('GRID', (0, 0), (-1, -1), 1, colors.black)\n            ]))\n            story.append(category_table)\n        \n        # Build PDF\n        doc.build(story)\n        buffer.seek(0)\n        \n        return send_file(\n            buffer,\n            as_attachment=True,\n            download_name=f'pos_report_{start_date}_{end_date}.pdf',\n            mimetype='application/pdf'\n        )\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@reports_bp.route('/export/excel', methods=['POST'])\n@login_required\ndef export_excel():\n    \"\"\"Export reports as Excel\"\"\"\n    try:\n        # Get the same data as reports route\n        start_date = request.args.get('start_date')\n        end_date = request.args.get('end_date')\n        \n        if not start_date:\n            start_date = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')\n        if not end_date:\n            end_date = datetime.now().strftime('%Y-%m-%d')\n        \n        # Get analytics data\n        daily_sales, category_analysis, top_products, inventory_report = get_reports_data(start_date, end_date)\n        \n        # Create Excel file\n        buffer = io.BytesIO()\n        \n        with pd.ExcelWriter(buffer, engine='openpyxl') as writer:\n            # Daily Sales Sheet\n            if daily_sales:\n                sales_df = pd.DataFrame([\n                    {\n                        'Date': sale['date'],\n                        'Revenue (₸)': sale['total_revenue'] or 0,\n                        'Profit (₸)': sale['total_profit'] or 0\n                    } for sale in daily_sales\n                ])\n                sales_df.to_excel(writer, sheet_name='Daily Sales', index=False)\n            \n            # Top Products Sheet\n            if top_products:\n                products_df = pd.DataFrame([\n                    {\n                        'Product': product['name'],\n                        'Quantity Sold': product['total_sold'],\n                        'Revenue (₸)': product['total_revenue'],\n                        'Profit (₸)': product['total_profit'] or 0,\n                        'Avg Profit per Unit (₸)': product['avg_profit_per_unit'] or 0\n                    } for product in top_products\n                ])\n                products_df.to_excel(writer, sheet_name='Top Products', index=False)\n            \n            # Category Analysis Sheet\n            if category_analysis:\n                categories_df = pd.DataFrame([\n                    {\n                        'Category': category['name'],\n                        'Total Transactions': category['total_transactions'],\n                        'Total Sold': category['total_sold'],\n                        'Revenue (₸)': category['total_revenue'],\n                        'Profit (₸)': category['total_profit'] or 0,\n                        'Profit Margin (%)': (category['total_profit'] / category['total_revenue'] * 100) if category['total_revenue'] > 0 else 0\n                    } for category in category_analysis\n                ])\n                categories_df.to_excel(writer, sheet_name='Category Analysis', index=False)\n            \n            # Inventory Report Sheet\n            if inventory_report:\n                inventory_df = pd.DataFrame([\n                    {\n                        'Product': item['name'],\n                        'SKU': item['sku'],\n                        'Stock Quantity': item['stock_quantity'],\n                        'Min Stock Level': item['min_stock_level'],\n                        'Price (₸)': item['price'],\n                        'Cost Price (₸)': item['cost_price'],\n                        'Profit per Unit (₸)': item['price'] - item['cost_price'],\n                        'Category': item['category_name'],\n                        'Supplier': item['supplier_name'],\n                        'Status': 'Low Stock' if item['stock_quantity'] <= item['min_stock_level'] else 'OK'\n                    } for item in inventory_report\n                ])\n                inventory_df.to_excel(writer, sheet_name='Inventory Report', index=False)\n        \n        buffer.seek(0)\n        \n        return send_file(\n            buffer,\n            as_attachment=True,\n            download_name=f'pos_report_{start_date}_{end_date}.xlsx',\n            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n        )\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@reports_bp.route('/api/analytics/top_products')\n@login_required\ndef get_top_products():\n    \"\"\"Get top selling products analytics\"\"\"\n    days = request.args.get('days', 30, type=int)\n    start_date = datetime.utcnow() - timedelta(days=days)\n    \n    # Top products by quantity\n    top_by_quantity = db.session.query(\n        Product.name,\n        Product.sku,\n        func.sum(TransactionItem.quantity).label('total_sold'),\n        func.sum(TransactionItem.total_price).label('total_revenue'),\n        func.count(TransactionItem.id).label('transaction_count')\n    ).join(TransactionItem).join(Transaction).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        Transaction.created_at >= start_date\n    ).group_by(Product.id, Product.name, Product.sku)\\\n     .order_by(desc('total_sold')).limit(10).all()\n    \n    # Low performing products\n    low_performing = db.session.query(\n        Product.name,\n        Product.sku,\n        func.sum(TransactionItem.quantity).label('total_sold'),\n        func.sum(TransactionItem.total_price).label('total_revenue')\n    ).join(TransactionItem).join(Transaction).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        Transaction.created_at >= start_date\n    ).group_by(Product.id, Product.name, Product.sku)\\\n     .order_by('total_sold').limit(10).all()\n    \n    return jsonify({\n        'top_products': [{\n            'name': p.name,\n            'sku': p.sku,\n            'total_sold': float(p.total_sold),\n            'total_revenue': float(p.total_revenue),\n            'transaction_count': p.transaction_count\n        } for p in top_by_quantity],\n        'low_performing': [{\n            'name': p.name,\n            'sku': p.sku,\n            'total_sold': float(p.total_sold),\n            'total_revenue': float(p.total_revenue)\n        } for p in low_performing]\n    })\n\n@reports_bp.route('/api/analytics/sales_summary')\n@login_required\ndef get_sales_summary():\n    \"\"\"Get sales summary for dashboard\"\"\"\n    today = datetime.utcnow().date()\n    start_of_month = today.replace(day=1)\n    \n    # Today's sales\n    today_sales = db.session.query(\n        func.sum(Transaction.total_amount),\n        func.count(Transaction.id)\n    ).filter(\n        func.date(Transaction.created_at) == today,\n        Transaction.status == TransactionStatus.COMPLETED\n    ).first()\n    \n    # Month's sales\n    month_sales = db.session.query(\n        func.sum(Transaction.total_amount),\n        func.count(Transaction.id)\n    ).filter(\n        func.date(Transaction.created_at) >= start_of_month,\n        Transaction.status == TransactionStatus.COMPLETED\n    ).first()\n    \n    # Low stock alerts\n    low_stock_products = Product.query.filter(\n        Product.stock_quantity <= Product.min_stock_level,\n        Product.is_active == True\n    ).count()\n    \n    return jsonify({\n        'today': {\n            'revenue': float(today_sales[0] if today_sales and today_sales[0] else 0),\n            'transactions': today_sales[1] if today_sales and today_sales[1] else 0\n        },\n        'month': {\n            'revenue': float(month_sales[0] if month_sales and month_sales[0] else 0),\n            'transactions': month_sales[1] if month_sales and month_sales[1] else 0\n        },\n        'low_stock_count': low_stock_products\n    })\n\ndef get_reports_data(start_date, end_date):\n    \"\"\"Helper function to get reports data\"\"\"\n    # Sales by day with profit calculation\n    daily_sales = db.session.query(\n        func.date(Transaction.created_at).label('date'),\n        func.sum(Transaction.total_amount).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit')\n    ).select_from(Transaction).join(\n        TransactionItem, Transaction.id == TransactionItem.transaction_id\n    ).join(\n        Product, TransactionItem.product_id == Product.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(func.date(Transaction.created_at)).all()\n    \n    # Top selling products with profit\n    top_products = db.session.query(\n        Product.name,\n        func.sum(TransactionItem.quantity).label('total_sold'),\n        func.sum(TransactionItem.total_price).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit'),\n        func.avg(Product.price - Product.cost_price).label('avg_profit_per_unit')\n    ).select_from(Product).join(\n        TransactionItem, Product.id == TransactionItem.product_id\n    ).join(\n        Transaction, TransactionItem.transaction_id == Transaction.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(Product.id, Product.name).order_by(desc('total_sold')).limit(10).all()\n    \n    # Category analysis - most popular categories\n    category_analysis = db.session.query(\n        Category.name,\n        func.count(TransactionItem.id).label('total_transactions'),\n        func.sum(TransactionItem.quantity).label('total_sold'),\n        func.sum(TransactionItem.total_price).label('total_revenue'),\n        func.sum(\n            TransactionItem.quantity * (Product.price - Product.cost_price)\n        ).label('total_profit')\n    ).select_from(Category).join(\n        Product, Category.id == Product.category_id\n    ).join(\n        TransactionItem, Product.id == TransactionItem.product_id\n    ).join(\n        Transaction, TransactionItem.transaction_id == Transaction.id\n    ).filter(\n        Transaction.status == TransactionStatus.COMPLETED,\n        func.date(Transaction.created_at) >= start_date,\n        func.date(Transaction.created_at) <= end_date\n    ).group_by(Category.id, Category.name).order_by(desc('total_revenue')).all()\n    \n    # Inventory analysis\n    inventory_report = db.session.query(\n        Product.name,\n        Product.sku,\n        Product.stock_quantity,\n        Product.min_stock_level,\n        Product.price,\n        Product.cost_price,\n        Category.name.label('category_name'),\n        Supplier.name.label('supplier_name')\n    ).select_from(Product).join(\n        Category, Product.category_id == Category.id\n    ).join(\n        Supplier, Product.supplier_id == Supplier.id\n    ).filter(\n        Product.is_active == True\n    ).order_by(Product.stock_quantity.asc()).all()\n    \n    # Convert Row objects to dictionaries for JSON serialization\n    daily_sales_data = [{\n        'date': str(row.date),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0)\n    } for row in daily_sales]\n    \n    category_analysis_data = [{\n        'name': row.name,\n        'total_transactions': int(row.total_transactions or 0),\n        'total_sold': float(row.total_sold or 0),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0)\n    } for row in category_analysis]\n    \n    top_products_data = [{\n        'name': row.name,\n        'total_sold': float(row.total_sold or 0),\n        'total_revenue': float(row.total_revenue or 0),\n        'total_profit': float(row.total_profit or 0),\n        'avg_profit_per_unit': float(row.avg_profit_per_unit or 0)\n    } for row in top_products]\n    \n    inventory_report_data = [{\n        'name': row.name,\n        'sku': row.sku,\n        'stock_quantity': int(row.stock_quantity or 0),\n        'min_stock_level': int(row.min_stock_level or 0),\n        'price': float(row.price or 0),\n        'cost_price': float(row.cost_price or 0),\n        'category_name': row.category_name,\n        'supplier_name': row.supplier_name\n    } for row in inventory_report]\n    \n    return daily_sales_data, category_analysis_data, top_products_data, inventory_report_data","size_bytes":26000}},"version":1}